function ’ê’è_Iterable(a){var b;return a.constructor===[].constructor||a.constructor==="".constructor||(b=Array.prototype.slice.call(a)).length?b||a:Object.keys(a)}function ’ê’è_bind(a,b){var a,c;return a.orig&&(a=a.orig),b===!1?a:(c=function(){return a.apply(b,arguments)},c.orig=a,c)}function range(a,b,c){var b,a,c,d,e,f;for(arguments.length<=1&&(b=a||0,a=0),c=arguments[2]||1,d=Math.max(Math.ceil((b-a)/c),0),e=0,f=new Array(d);e<d;)f[e++]=a,a+=c;return f}function ’ê’è_in(a,b){return"function"==typeof b.indexOf?b.indexOf(a)!==-1:b.hasOwnProperty(a)}function len(a){var b;return a.constructor===[].constructor||a.constructor==="".constructor||(b=Array.prototype.slice.call(a)).length?(b||a).length:Object.keys(a).length}function dir(a){var b;b=[];for(var c in a)b.push(c);return b}function ’ê’è_extends(a,b){a.prototype=Object.create(b.prototype),a.prototype.__base__=b,a.prototype.constructor=a}function abs(a){return Math.abs(a)}function all(a){var b,c,d;for(b=’ê’è_Iterable(a),c=0;c<b.length;c++)if(d=b[c],!d)return!1;return!0}function any(a){var b,c,d;for(b=’ê’è_Iterable(a),c=0;c<b.length;c++)if(d=b[c])return!0;return!1}function bin(a){return"0b"+(a>>>0).toString(2)}function ’ê’è_rebindAll(a,b){var b;void 0===b&&(b=!0);for(var c in a)a[c]&&a[c].orig&&(b?a[c]=’ê’è_bind(a[c],a):a[c]=a[c].orig)}function cmp(a,b){return a<b?-1:a>b?1:0}function enumerate(a){var b,c,d;for(b=[],c=’ê’è_Iterable(a),d=0;d<c.length;d++)b[b.length]=[d,a[d]];return b}function ’ê’è_eslice(a,b,c,d){var a,e,b,c,d;return a=a.slice(0),("string"==typeof a||a instanceof String)&&(e=!0,a=a.split("")),b<0&&(b=-b,a.reverse(),"undefined"!=typeof c&&(c=a.length-c-1),"undefined"!=typeof d&&(d=a.length-d-1)),"undefined"==typeof c&&(c=0),"undefined"==typeof d&&(d=a.length),a=a.slice(c,d).filter(function(a,c){return c%b===0}),e?a.join(""):a}function filter(a,b){return b.filter(a)}function hex(a){return"0x"+(a>>>0).toString(16)}function map(a,b){return b.map(a)}function max(a){return Array.isArray(a)?Math.max.apply(null,a):Math.max.apply(null,arguments)}function min(a){return Array.isArray(a)?Math.min.apply(null,a):Math.min.apply(null,arguments)}function ’ê’è_merge(a,b,c){for(var d in b)b.hasOwnProperty(d)&&(c||"undefined"==typeof a[d])&&(a[d]=b[d]);for(var d in b.prototype)b.prototype.hasOwnProperty(d)&&(c||"undefined"==typeof a.prototype[d])&&(a.prototype[d]=b.prototype[d])}function ’ê’è_mixin(){var a=[].slice.call(arguments,0);return function(b){var c,d,e,f,g,h;for(c=’ê’è_Iterable(a),d=0;d<c.length;d++)for(g=c[d],e=’ê’è_Iterable(Object.keys(g.prototype)),f=0;f<e.length;f++)h=e[f],’ê’è_in(h,b.prototype)||(b.prototype[h]=g.prototype[h]);return b}}function ’ê’è_print(){"object"==typeof console&&console.log.apply(console,arguments)}function reduce(a,b){return Array.prototype.reduce.call(b,a)}function reversed(a){var b;return b=a.slice(0),b.reverse()}function sorted(a){var b;return b=a.slice(0),b.sort()}function sum(a,b){return b=void 0===b?0:b,a.reduce(function(a,b){return a+b},b)}function ’ê’è_type(a){return a.constructor&&a.constructor.name?a.constructor.name:Object.prototype.toString.call(a).slice(8,-1)}function zip(a,b){return function(){var c,f,d=’ê’è_Iterable(range(Math.min(a.length,b.length))),e=[];for(c=0;c<d.length;c++)f=d[c],e.push([a[f],b[f]]);return e}()}function getattr(a,b){return a[b]}function setattr(a,b,c){a[b]=c}function hasattr(a,b){return b in a}function kwargs(a){var b;return b=a.toString().match(/\(([^\)]+)/)[1],kwargs.memo[b]||(kwargs.memo[b]=b?b.split(",").map(function(a){return a.trim()}):[]),b=kwargs.memo[b],function(){var c,d,e;if(c=[].slice.call(arguments),c.length)if(d=c[c.length-1],"object"==typeof d)for(e=0;e<b.length;e++)’ê’è_in(b[e],dir(d))&&(c[e]=d[b[e]]);else c.push(d);return a.apply(this,c)}}var ’ê’è_1,’ê’è_2,’ê’è_3,’ê’è_4,’ê’è_5,’ê’è_6;chr=String.fromCharCode;var ’ê’è_eq=(’ê’è_1=function a(b,c){var d,e,f;if(b===c)return!0;if(Array.isArray(b)&&Array.isArray(c)||b instanceof Object&&c instanceof Object){if(b.constructor!==c.constructor||b.length!==c.length)return!1;if(Array.isArray(b)){for(f=0;f<len(b);f++)if(!a(b[f],c[f]))return!1}else{if(Object.keys(b).length!==Object.keys(c).length)return!1;for(d=’ê’è_Iterable(b),e=0;e<d.length;e++)if(f=d[e],!a(b[f],c[f]))return!1}return!0}return!1},Object.defineProperty(’ê’è_1,"__doc__",{value:"Equality comparison that works with all data types, returns true if structure and\ncontents of first object equal to those of second object\n\nArguments:\n    a: first object\n    b: second object"}),’ê’è_1);kwargs.memo={};var AssertionError=(’ê’è_2=function a(){a.prototype.__init__.apply(this,arguments)},’ê’è_extends(’ê’è_2,Error),Object.defineProperties(’ê’è_2.prototype,{__init__:{enumerable:!0,writable:!0,value:function(b){var c=this;c.name="AssertionError",c.message=b}}}),’ê’è_2),IndexError=(’ê’è_3=function a(){a.prototype.__init__.apply(this,arguments)},’ê’è_extends(’ê’è_3,Error),Object.defineProperties(’ê’è_3.prototype,{__init__:{enumerable:!0,writable:!0,value:function(b){var c=this;c.name="IndexError",c.message=b}}}),’ê’è_3),KeyError=(’ê’è_4=function a(){a.prototype.__init__.apply(this,arguments)},’ê’è_extends(’ê’è_4,Error),Object.defineProperties(’ê’è_4.prototype,{__init__:{enumerable:!0,writable:!0,value:function(b){var c=this;c.name="KeyError",c.message=b}}}),’ê’è_4),TypeError=(’ê’è_5=function a(){a.prototype.__init__.apply(this,arguments)},’ê’è_extends(’ê’è_5,Error),Object.defineProperties(’ê’è_5.prototype,{__init__:{enumerable:!0,writable:!0,value:function(b){var c=this;c.name="TypeError",c.message=b}}}),’ê’è_5),ValueError=(’ê’è_6=function a(){a.prototype.__init__.apply(this,arguments)},’ê’è_extends(’ê’è_6,Error),Object.defineProperties(’ê’è_6.prototype,{__init__:{enumerable:!0,writable:!0,value:function(b){var c=this;c.name="ValueError",c.message=b}}}),’ê’è_6);function array_to_hash(a){var b,c;for(b=Object.create(null),c=0;c<len(a);c++)b[a[c]]=!0;return b}function slice(a,b){return Array.prototype.slice.call(a,b||0)}function characters(a){return a.split("")}function member(a,b){var c,d,e;for(c=’ê’è_Iterable(range(b.length-1,-1,-1)),d=0;d<c.length;d++)if(e=c[d],b[e]===a)return!0;return!1}function find_if(a,b){var c;for(c=0;c<len(b);c++)if(a(b[c]))return b[c]}function repeat_string(a,b){var c;return b<=0?"":1===b?a:(c=repeat_string(a,b>>1),c+=c,1&b&&(c+=a),c)}function DefaultsError(a,b){this.msg=a,this.defs=b}function defaults(a,b,c){var d,e,f,g,a,h,i;if(a===!0&&(a={}),h=a||{},c)for(d=’ê’è_Iterable(h),e=0;e<d.length;e++)if(i=d[e],!’ê’è_in(i,b))throw new DefaultsError("`"+i+"` is not a supported option",b);for(f=’ê’è_Iterable(b),g=0;g<f.length;g++)i=f[g],h[i]=a&&’ê’è_in(i,a)?a[i]:b[i];return h}function merge(a,b){var c,d,e;for(c=’ê’è_Iterable(b),d=0;d<c.length;d++)e=c[d],a[e]=b[e];return a}function noop(){}function push_uniq(a,b){’ê’è_in(b,a)||a.push(b)}function string_template(a,b){return a.replace(/\{(.+?)\}/g,function(a,c){return b[c]})}function remove(a,b){var c,d,e;for(c=’ê’è_Iterable(range(a.length-1,-1,-1)),d=0;d<c.length;d++)e=c[d],a[e]===b&&a.splice(i,1)}function mergeSort(a,b){function d(a){var b,c,e;return a.length<=1?a:(b=Math.floor(a.length/2),c=a.slice(0,b),e=a.slice(b),c=d(c),e=d(e),’ê’è_merge(c,e))}return a.length<2?a.slice():d(a)}function set_difference(a,b){return a.filter(function(a){return!’ê’è_in(a,b)})}function set_intersection(a,b){return a.filter(function(a){return ’ê’è_in(a,b)})}function makePredicate(a){function h(a){var c;if(1===a.length)return b+="return str === "+JSON.stringify(a[0])+";";for(b+="switch(str){",c=0;c<len(a);c++)b+="case "+JSON.stringify(a[c])+":";b+="return true}return false;"}var a,b,c,d,e,f,g;for(Array.isArray(a)||(a=a.split(" ")),b="",c=[],d=0;d<len(a);d++){for(e=!1,f=0;f<len(c);f++)if(c[f][0].length===a[d].length){c[f].push(a[d]),e=!0;break}e||c.push([a[d]])}if(c.length>3){for(c.sort(function(a,b){return b.length-a.length}),b+="switch(str.length){",d=0;d<len(c);d++)g=c[d],b+="case "+g[0].length+":",h(g);b+="}"}else h(a);return new Function("str",b)}function Dictionary(){this._values=Object.create(null),this._size=0}function ansi(a){var a;return a=a||0,"["+a+"m"}function colored(a,b,c){var d;return d=[],c&&d.push(ansi(1)),b&&d.push(ansi(colors.indexOf(b)+31)),d.join("")+a+ansi(0)}var ’ê’è_1,’ê’è_2,MAP,colors,ImportError=(’ê’è_1=function a(){a.prototype.__init__.apply(this,arguments)},’ê’è_extends(’ê’è_1,Error),Object.defineProperties(’ê’è_1.prototype,{__init__:{enumerable:!0,writable:!0,value:function(b){var c=this;c.message=b}}}),’ê’è_1),ParseError=(’ê’è_2=function a(){a.prototype.__init__.apply(this,arguments)},’ê’è_extends(’ê’è_2,Error),Object.defineProperties(’ê’è_2.prototype,{__init__:{enumerable:!0,writable:!0,value:function(b,c,d,e,f){var g=this;g.message=b,g.line=c,g.col=d,g.pos=e,g.stack=(new Error).stack,g.is_eof=f}},toString:{enumerable:!0,writable:!0,value:function(){return this.message+" (line: "+this.line+", col: "+this.col+", pos: "+this.pos+")\n\n"+this.stack}}}),’ê’è_2);MAP=function(){function b(b,f,g){function m(){var h,i;return h=f(b[l],l),i=h instanceof e,i&&(h=h.v),h instanceof c?(h=h.v,h instanceof d?k.push.apply(k,g?h.v.slice().reverse():h.v):k.push(h)):h!==a&&(h instanceof d?j.push.apply(j,g?h.v.slice().reverse():h.v):j.push(h)),i}var h,i,j,k,l;if(j=[],k=[],Array.isArray(b))if(g){for(h=’ê’è_Iterable(range(b.length-1,-1,-1)),i=0;i<h.length&&(l=h[i],!m());i++);j.reverse(),k.reverse()}else for(l=0;l<len(b)&&!m();l++);else for(l in b)if(b.hasOwnProperty(l)&&m())break;return k.concat(j)}function c(a){this.v=a}function d(a){this.v=a}function e(a){this.v=a}var a;return b.at_top=function(a){return new c(a)},b.splice=function(a){return new d(a)},b.last=function(a){return new e(a)},a=b.skip={},b}.call(this),Dictionary.prototype={set:function(a,b){return this.has(a)||++this._size,this._values["$"+a]=b,this},add:function(a,b){return this.has(a)?this.get(a).push(b):this.set(a,[b]),this},get:function(a){return this._values["$"+a]},del_:function(a){return this.has(a)&&(--this._size,delete this._values["$"+a]),this},has:function(a){return ’ê’è_in("$"+a,this._values)},each:function(a){var b;for(b in this._values)a(this._values[b],b.substr(1))},size:function(){return this._size},map:function(a){var b,c;b=[];for(c in this._values)b.push(a(this._values[c],c.substr(1)));return b}},colors=["red","green","yellow","blue","magenta","cyan","white"];function DEFNODE(a,b,c,d){function m(a){return function(b){return this.computedType||(this.computedType=a.call(this,b)),this.computedType}}var e,f,d,b,g,h,i,j,k,l;for(arguments.length<4&&(d=AST_Node),b=b?b.split(/\s+/):[],g=b,d&&d.PROPS&&(b=b.concat(d.PROPS)),h="return function AST_"+a+"(props){ if (props) { ",e=’ê’è_Iterable(range(b.length-1,-1,-1)),f=0;f<e.length;f++)i=e[f],h+="this."+b[i]+" = props."+b[i]+";";if(j=d&&new d,(j&&j.initialize||c&&c.initialize)&&(h+="this.initialize();"),h+="}}",k=new Function(h)(),j&&(k.prototype=j,k.BASE=d),d&&d.SUBCLASSES.push(k),k.prototype.CTOR=k,k.PROPS=b||null,k.SELF_PROPS=g,k.SUBCLASSES=[],a&&(k.prototype.TYPE=k.TYPE=a),c)for(l in c)c.hasOwnProperty(l)&&("resolveType"===l?k.prototype[l]=m(c[l]):/^\$/.test(l)?k[l.slice(1)]=c[l]:k.prototype[l]=c[l]);return k.DEFMETHOD=function(a,b){this.prototype[a]=b},k}function walk_body(a,b){var c,d,e;if(a.body instanceof AST_Statement)a.body._walk(b);else if(a.body)for(c=’ê’è_Iterable(a.body),d=0;d<c.length;d++)e=c[d],e._walk(b)}function TreeWalker(a){this.visit=a,this.stack=[]}var ’ê’è_1,’ê’è_2,AST_Token,AST_Node,AST_Statement,AST_Debugger,AST_Directive,AST_SimpleStatement,AST_Block,AST_BlockStatement,AST_EmptyStatement,AST_StatementWithBody,AST_LabeledStatement,AST_DWLoop,AST_Do,AST_While,AST_ForIn,AST_ForJS,AST_ListComprehension,AST_DictComprehension,AST_With,AST_Scope,AST_Toplevel,AST_Splat,AST_Import,AST_Imports,AST_Decorator,AST_Annotation,AST_Lambda,AST_Accessor,AST_Function,AST_Class,AST_Module,AST_Method,AST_Jump,AST_Exit,AST_Return,AST_Yield,AST_Throw,AST_LoopControl,AST_Break,AST_Continue,AST_If,AST_Switch,AST_SwitchBranch,AST_Default,AST_Case,AST_Try,AST_Catch,AST_Except,AST_Finally,AST_Definitions,AST_Var,AST_Const,AST_VarDef,AST_BaseCall,AST_Call,AST_ClassCall,AST_New,AST_Seq,AST_PropAccess,AST_Dot,AST_Sub,AST_Slice,AST_Unary,AST_UnaryPrefix,AST_UnaryPostfix,AST_Binary,AST_Range,AST_DeepEquality,AST_Conditional,AST_Assign,AST_Array,AST_TupleUnpack,AST_Object,AST_ObjectProperty,AST_ObjectKeyVal,AST_ObjectSetter,AST_ObjectGetter,AST_Symbol,AST_SymbolAlias,AST_SymbolAccessor,AST_SymbolDeclaration,AST_SymbolVar,AST_SymbolNonlocal,AST_ImportedVar,AST_SymbolConst,AST_SymbolFunarg,AST_SymbolDefun,AST_SymbolLambda,AST_SymbolCatch,AST_Label,AST_SymbolRef,AST_SymbolClassRef,AST_LabelRef,AST_This,AST_Constant,AST_String,AST_Verbatim,AST_Number,AST_Identifier,AST_RegExp,AST_Atom,AST_Null,AST_NaN,AST_Undefined,AST_Hole,AST_Infinity,AST_Boolean,AST_False,AST_True;AST_Token=DEFNODE("Token","type subtype value line col pos endpos newline_before comments_before file",{},null),AST_Node=DEFNODE("Node","start end",{clone:function(){return new this.CTOR(this)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},_walk:function(a){return a._visit(this)},walk:function(a){return this._walk(a)},_dump:(’ê’è_1=function(a,b,c,d,e){function s(a){var b;b=new Array(c+1).join("  "),console.log(b+a)}var f,g,h,i,j,k,l,m,n,o,p,q,r;for(d&&s(colored(this.TYPE,"yellow")),f=’ê’è_Iterable(this),g=0;g<f.length;g++)if(n=f[g],!’ê’è_in(n,b))if(o=colored(n+": ","blue"),p=this[n],Array.isArray(p))if(p.length){if(s(" "+o+"["),a>1)for(h=’ê’è_Iterable(p),i=0;i<h.length;i++)q=h[i],q._dump(a-1,b,c+1,!0,e);else for(j=’ê’è_Iterable(p),k=0;k<j.length;k++)q=j[k],s("   "+colored(q.TYPE,"yellow"));s(" ]")}else e||s(" "+o+"[]");else if(’ê’è_in(p,[void 0,null]))e||s(" "+o+p);else if(p.TYPE)if("Token"===p.TYPE)if(e)s(" "+o+colored(p.TYPE+"("+p.file+":"+p.line+":"+p.col+": "+p.value+")","magenta"));else for(s(" "+o+colored(p.TYPE,"magenta")),l=’ê’è_Iterable(p),m=0;m<l.length;m++)r=l[m],s("   "+colored(r+": ","blue")+p[r]);else s(" "+o+colored(p.TYPE,"yellow")),a>1&&p._dump(a-1,b,c+1,!1,e);else s("string"==typeof p?" "+o+colored('"'+p+'"',"green"):"number"==typeof p?" "+o+colored(p,"green"):"boolean"==typeof p?" "+o+colored(p,"green"):" "+o+colored(p,"red"))},Object.defineProperty(’ê’è_1,"__doc__",{value:"Dump node structure, used for debugging:\n\n    depth: how many nodes below to dump\n    omit: properties to omit\n    offset: padding offset to use\n    include_name: whether to output the name of the node\n    compact: use compact representation of the node"}),’ê’è_1),dump:function(a,b,c){return a=void 0===a?2:a,b=void 0===b?["start","end"]:b,c=void 0===c||c,this._dump(a,b,0,!0,c)},computedType:null,resolveType:(’ê’è_2=function(a){return"?"},Object.defineProperty(’ê’è_2,"__doc__",{value:"Function to resolve the final object type of the statement, if possible, override this on\nper-node basis"}),’ê’è_2)},null),AST_Node.warn_function=null,AST_Node.warn=function(a,b){AST_Node.warn_function&&AST_Node.warn_function(string_template(a,b))},AST_Statement=DEFNODE("Statement",null,{$documentation:"Base class of all statements"}),AST_Debugger=DEFNODE("Debugger",null,{$documentation:"Represents a debugger statement"},AST_Statement),AST_Directive=DEFNODE("Directive","value scope",{$documentation:'Represents a directive, like "use strict";',$propdoc:{value:"[string] The value of this directive as a plain string (it's not an AST_String!)",scope:"[AST_Scope/S] The scope that this directive affects"}},AST_Statement),AST_SimpleStatement=DEFNODE("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.body._walk(a)})}},AST_Statement),AST_Block=DEFNODE("Block","body",{$documentation:"A body of statements (usually bracketed)",$propdoc:{body:"[AST_Statement*] an array of statements"},_walk:function(a){var b;return b=this,a._visit(this,function(){walk_body(b,a)})}},AST_Statement),AST_BlockStatement=DEFNODE("BlockStatement",null,{$documentation:"A block statement"},AST_Block),AST_EmptyStatement=DEFNODE("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)",_walk:function(a){return a._visit(this)}},AST_Statement),AST_StatementWithBody=DEFNODE("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.body._walk(a)})}},AST_Statement),AST_LabeledStatement=DEFNODE("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.label._walk(a),b.body._walk(a)})}},AST_StatementWithBody),AST_DWLoop=DEFNODE("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.condition._walk(a),b.body._walk(a)})}},AST_StatementWithBody),AST_Do=DEFNODE("Do",null,{$documentation:"A `do` statement"},AST_DWLoop),AST_While=DEFNODE("While",null,{$documentation:"A `while` statement"},AST_DWLoop),AST_ForIn=DEFNODE("ForIn","init name object",{$documentation:"A `for ... in` statement",$propdoc:{init:"[AST_Node] the `for/in` initialization code",name:"[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",object:"[AST_Node] the object that we're looping through"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.init._walk(a),b.object._walk(a),b.body._walk(a)})}},AST_StatementWithBody),AST_ForJS=DEFNODE("ForJS","condition",{$documentation:"A `for ... in` statement",$propdoc:{condition:"[AST_Verbatim] raw JavaScript conditional"}},AST_StatementWithBody),AST_ListComprehension=DEFNODE("ListComprehension","condition statement",{$documentation:"A list comprehension expression",$propdoc:{condition:"[AST_Node] the `if` condition",statement:"[AST_Node] statement to perform on each element before returning it"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.init._walk(a),b.condition&&b.condition._walk(a),b.statement._walk(a)})}},AST_ForIn),AST_DictComprehension=DEFNODE("DictComprehension","value_statement",{$documentation:"A dict comprehension expression",$propdoc:{value_statement:"[AST_Node] statement to perform on each value before returning it"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.init._walk(a),b.statement._walk(a),b.value_statement._walk(a),b.condition&&b.condition._walk(a)})}},AST_ListComprehension),AST_With=DEFNODE("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.expression._walk(a),b.body._walk(a)})}},AST_StatementWithBody),AST_Scope=DEFNODE("Scope","docstring directives variables localvars functions parent_scope enclosed cname",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{docstring:"[string?] docstring for this scope, if any",directives:"[string*/S] an array of directives declared in this scope",variables:"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",localvars:"[SymbolDef*] list of variables local to this scope",functions:"[Object/S] like `variables`, but only lists function declarations",parent_scope:"[AST_Scope?/S] link to the parent scope",enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes"}},AST_Block),AST_Toplevel=DEFNODE("Toplevel","globals baselib imports strict shebang import_order module_id exports submodules classes filename srchash",{$documentation:"The toplevel scope",$propdoc:{globals:"[Object/S] a map of name -> SymbolDef for all undeclared names",baselib:"[Object/s] a collection of used parts of baselib",imports:"[Object/S] a map of module_id->AST_Toplevel for all imported modules",nonlocalvars:"[String*] a list of all non-local variable names (names that come from the global scope)",strict:"[boolean/S] true if strict directive is in scope",shebang:"[string] If #! line is present, it will be stored here",import_order:"[number] The global order in which this scope was imported",module_id:"[string] The id of this module",exports:"[SymbolDef*] list of names exported from this module",submodules:"[string*] list of names exported from this module",classes:"[Object/S] a map of class names to AST_Class for classes defined in this module",filename:"[string] The absolute path to the file from which this module was read",srchash:"[string] SHA1 hash of source code, used for caching"},wrap_enclose:function(a){var b,c,d,e,f,g,h,i;for(d=this,e=[],f=[],b=’ê’è_Iterable(a),c=0;c<b.length;c++)g=b[c],h=g.split(":"),e.push(h[0]),f.push(h[1]);return i="(function("+f.join(",")+"){ '$ORIG'; })("+e.join(",")+")",i=parse(i),i=i.transform(new TreeTransformer(function(b){if(b instanceof AST_Directive&&"$ORIG"===b.value)return MAP.splice(d.body)}))},wrap_commonjs:function(a,b){var c,d,e;return c=this,d=[],b&&(c.figure_out_scope(),c.walk(new TreeWalker(function(a){a instanceof AST_SymbolDeclaration&&a.definition().global&&(find_if(function(b){return b.name===a.name},d)||d.push(a))}))),e="(function(exports, global){ global['"+a+"'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))",e=parse(e),e=e.transform(new TreeTransformer(function(b){var e,f,b,g,h,i;if(b instanceof AST_SimpleStatement&&(b=b.body,b instanceof AST_String)){if(g=b.getValue(),"$ORIG"===g)return MAP.splice(c.body);if("$EXPORTS"===g){for(h=[],e=’ê’è_Iterable(d),f=0;f<e.length;f++)i=e[f],h.push(new AST_SimpleStatement({body:new AST_Assign({left:new AST_Sub({expression:new AST_SymbolRef({name:"exports"}),property:new AST_String({value:i.name})}),operator:"=",right:new AST_SymbolRef(i)})}));return MAP.splice(h)}}}))}},AST_Scope),AST_Splat=DEFNODE("Splat","module key body",{$documentation:"Container for a naive import into the same scope, everything contained within the splat will be imported",$propdoc:{module:"[AST_SymbolVar] name of the module we're splatting",key:"[string] The key by which this module is stored in the global modules mapping",body:"[AST_TopLevel] parsed contents of the imported file"}},AST_Statement),AST_Import=DEFNODE("Import","module key alias argnames body",{$documentation:"Container for a single import",$propdoc:{module:"[AST_SymbolVar] name of the module we're importing",key:"[string] The key by which this module is stored in the global modules mapping",alias:"[AST_SymbolAlias] The name this module is imported as, can be None. For import x as y statements.",argnames:"[AST_ImportedVar*] names of objects to be imported",body:"[AST_TopLevel] parsed contents of the imported file"},_walk:function(a){var b;return b=this,a._visit(b,function(){var c,d,e;for(c=’ê’è_Iterable(b.argnames),d=0;d<c.length;d++)e=c[d],e._walk(a)})}},AST_Statement),AST_Imports=DEFNODE("Imports","imports",{$documentation:"Container for a single import",$propdoc:{imports:"[AST_Import+] array of imports"},_walk:function(a){var b;return b=this,a._visit(b,function(){var c,d,e;for(c=’ê’è_Iterable(b.imports),d=0;d<c.length;d++)e=c[d],e._walk(a)})}},AST_Statement),AST_Decorator=DEFNODE("Decorator","expression",{$documentation:"Class for function decorators",$propdoc:{expression:"[AST_Node] decorator expression"},_walk:function(a){this.expression&&this.expression.walk(a)}}),AST_Annotation=DEFNODE("Annotation","expression",{$documentation:"Class for argument/return annotations",$propdoc:{expression:"[AST_Node] decorator expression"},_walk:function(a){this.expression&&this.expression.walk(a)},resolveType:function(a){function b(a){var c;if(a instanceof AST_Array)return 1===a.elements.length?"["+b(a.elements[0])+"]":"[?]";if(a instanceof AST_Object)return 1===a.properties.length?"{String:"+b(a.properties[0].value)+"}":"{String:?}";if(a instanceof AST_SymbolRef)return"Array"===a.name?"[?]":’ê’è_in(a.name,["Object","Dictionary"])?"{String:?}":a.name;if(a instanceof AST_Call){if(a.expression instanceof AST_SymbolRef&&"Array"===a.expression.name&&1===a.args.length)return"["+b(a.args[0])+"]";if(a.expression instanceof AST_SymbolRef&&’ê’è_in(a.expression.name,["Object","Dictionary"]))return 1<=(c=a.args.length)&&c<=2?"{String:"+b(a.args[a.args.length-1])+"}":"{String:?}"}return"?"}return b(this.expression)}}),AST_Lambda=DEFNODE("Lambda","name argnames kwargs uses_arguments decorators generator return_annotation",{$documentation:"Base class for functions",$propdoc:{name:"[AST_SymbolDeclaration?] the name of this function/class/method",argnames:"[AST_SymbolFunarg*] array of arguments",kwargs:"[AST_SymbolFunarg?] kwargs symbol, if any",uses_arguments:"[boolean/S] tells whether this function accesses the arguments array",decorators:"[AST_Decorator*] function decorators, if any",generator:"[boolean] true if this is a generator function (false by default)",return_annotation:"[AST_Annotation?] the return type annotation provided (if any)"},_walk:function(a){var b;return b=this,a._visit(b,function(){var c,d,e,f,g,h;if(b.decorators)for(c=’ê’è_Iterable(b.decorators),d=0;d<c.length;d++)g=c[d],g.walk(a);for(b.name&&b.name._walk(a),e=’ê’è_Iterable(b.argnames),f=0;f<e.length;f++)h=e[f],h._walk(a);b.argnames.starargs&&b.argnames.starargs._walk(a),b.kwargs&&b.kwargs._walk(a),walk_body(b,a)})}},AST_Scope),AST_Accessor=DEFNODE("Accessor",null,{$documentation:"A setter/getter function"},AST_Lambda),AST_Function=DEFNODE("Function",null,{$documentation:"A function expression",resolveType:function(a){var b,c,d,e,f,g,h,i;if(this.argnames.starargs)return"Function";for(d=!0,e=[],b=’ê’è_Iterable(this.argnames),c=0;c<b.length;c++){if(f=b[c],!f.annotation){d=!1;break}if(g=f.annotation.resolveType(a),!g){d=!1;break}e.push(g)}return this.return_annotation&&(h=this.return_annotation.resolveType(a),h||(d=!1)),i="Function",d&&(i+="("+e.join(",")+")",h&&(i+=" -> "+h)),i}},AST_Lambda),AST_Class=DEFNODE("Class","init name parent static external bound decorators module_id statements",{$documentation:"A class declaration",$propdoc:{name:"[AST_SymbolDeclaration?] the name of this class",init:"[AST_Function] constructor for the class",parent:"[AST_Class?] parent class this class inherits from",static:"[string*] list of static methods",external:"[boolean] true if class is declared elsewhere, but will be within current scope at runtime",bound:"[string*] hash of methods that need to be bound to behave correctly (function pointers)",decorators:"[AST_Decorator*] function decorators, if any",module_id:"[string] The id of the module this class is defined in",statements:"[AST_Node*] list of statements in the class scope (excluding method definitions)"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.name._walk(a),walk_body(this,a),b.parent&&b.parent._walk(a)})},resolveType:function(a){return this.name.name}},AST_Scope),AST_Module=DEFNODE("Module","name external decorators",{$documentation:"A module definition, meant to abstract a group of related classes and/or functions",$propdoc:{name:"[AST_SymbolDeclaration?] the name of this class",external:"[boolean] true if module is declared elsewhere, but will be within current scope at runtime",decorators:"[AST_Decorator*] module decorators, if any"}},AST_Scope),AST_Method=DEFNODE("Method","static",{$documentation:"A class method definition",$propdoc:{static:"[boolean] true if method is static"}},AST_Lambda),AST_Jump=DEFNODE("Jump",null,{$documentation:"Base class for ‚Äújumps‚Äù (for now that's `return`, `throw`, `break` and `continue`)"},AST_Statement),AST_Exit=DEFNODE("Exit","value",{$documentation:"Base class for ‚Äúexits‚Äù (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.value&&b.value._walk(a)})},resolveType:function(a){return this.value.resolveType(a)}},AST_Jump),AST_Return=DEFNODE("Return",null,{$documentation:"A `return` statement"},AST_Exit),AST_Yield=DEFNODE("Yield",null,{$documentation:"A `yield` statement"},AST_Exit),AST_Throw=DEFNODE("Throw",null,{$documentation:"A `throw` statement"},AST_Exit),AST_LoopControl=DEFNODE("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.label&&b.label._walk(a)})}},AST_Jump),AST_Break=DEFNODE("Break",null,{$documentation:"A `break` statement"},AST_LoopControl),AST_Continue=DEFNODE("Continue",null,{$documentation:"A `continue` statement"},AST_LoopControl),AST_If=DEFNODE("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.condition._walk(a),b.body._walk(a),b.alternative&&b.alternative._walk(a)})}},AST_StatementWithBody),AST_Switch=DEFNODE("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` ‚Äúdiscriminant‚Äù"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.expression._walk(a),walk_body(b,a)})}},AST_Block),AST_SwitchBranch=DEFNODE("SwitchBranch",null,{$documentation:"Base class for `switch` branches"},AST_Block),AST_Default=DEFNODE("Default",null,{$documentation:"A `default` switch branch"},AST_SwitchBranch),AST_Case=DEFNODE("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.expression._walk(a),walk_body(b,a)})}},AST_SwitchBranch),AST_Try=DEFNODE("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_walk:function(a){var b;return b=this,a._visit(b,function(){walk_body(b,a),b.bcatch&&b.bcatch._walk(a),b.bfinally&&b.bfinally._walk(a)})}},AST_Block),AST_Catch=DEFNODE("Catch",null,{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{}},AST_Block),AST_Except=DEFNODE("Except","argname errors",{$documentation:"An `except` node for RapydScript, which resides inside the catch block",$propdoc:{argname:"[AST_SymbolCatch] symbol for the exception",errors:"[AST_SymbolVar*] error classes to catch in this block"},_walk:function(a){var b;return b=this,a._visit(b,function(){var c,d,e;if(b.argname&&b.argname.walk(a),b.errors)for(c=’ê’è_Iterable(b.errors),d=0;d<c.length;d++)e=c[d],e.walk(a);walk_body(b,a)})}},AST_Block),AST_Finally=DEFNODE("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},AST_Block),AST_Definitions=DEFNODE("Definitions","definitions",{$documentation:"Base class for `var` or `const` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_walk:function(a){var b;return b=this,a._visit(b,function(){var c,d,e;for(c=’ê’è_Iterable(b.definitions),d=0;d<c.length;d++)e=c[d],e._walk(a)})}},AST_Statement),AST_Var=DEFNODE("Var",null,{$documentation:"A `var` statement"},AST_Definitions),AST_Const=DEFNODE("Const",null,{$documentation:"A `const` statement"},AST_Definitions),AST_VarDef=DEFNODE("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_SymbolVar|AST_SymbolConst] name of the variable",value:"[AST_Node?] initializer, or null if there's no initializer"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.name._walk(a),b.value&&b.value._walk(a)})}}),AST_BaseCall=DEFNODE("BaseCall","args",{$documentation:"A base class for function calls",$propdoc:{args:"[AST_Node*] array of arguments"}}),AST_Call=DEFNODE("Call","expression",{$documentation:"A function call expression",$propdoc:{expression:"[AST_Node] expression to invoke as function"},_walk:function(a){var b;return b=this,a._visit(b,function(){var c,d,e,f,g,h,i;for(b.expression._walk(a),c=’ê’è_Iterable(b.args),d=0;d<c.length;d++)i=c[d],i._walk(a);if(b.args.kwargs)for(e=’ê’è_Iterable(b.args.kwargs),f=0;f<e.length;f++)i=e[f],i[0]._walk(a),i[1]._walk(a);if(b.args.kwarg_items)for(g=’ê’è_Iterable(b.args.kwarg_items),h=0;h<g.length;h++)i=g[h],i._walk(a)})},resolveType:function(a){var b,c,d,e,f;if(this.expression instanceof AST_SymbolRef)for(b=’ê’è_Iterable(reversed(a)),c=0;c<b.length;c++){if(d=b[c],’ê’è_in(this.expression.name,d.vars)&&’ê’è_in("->",d.vars[this.expression.name][d.vars[this.expression.name].length-1]))return d.vars[this.expression.name][d.vars[this.expression.name].length-1].split("->")[1].trim();if(’ê’è_in(this.expression.name,d.functions)&&’ê’è_in("->",d.functions[this.expression.name]))return d.functions[this.expression.name].split("->")[1].trim();if("function"===d.type&&this.expression.name===d.name&&d.return&&(e=function(a){var b,c,d,f,g;if(c={array:function(a){return"["+a+"]"},dict:function(a){return"{String:"+a+"}"},base:function(a){return a}},d="base",a instanceof AST_Array){if(1!==a.elements.length)return;d="array",f=a.elements[0]}else if(a instanceof AST_Call&&a.expression instanceof AST_SymbolRef&&"Array"===a.expression.name){if(1!==a.args.length)return;d="array",f=a.args[0]}else if(a instanceof AST_Object){if(1!==a.properties.length)return;d="dict",f=a.properties[0].value}else if(a instanceof AST_Call&&a.expression instanceof AST_SymbolRef&&’ê’è_in(a.expression.name,["Object","Dictionary"])){if(!(1<=(b=a.args.length)&&b<=2))return;f=a.args[a.args.length-1],d="dict"}else f=a;return f instanceof AST_SymbolRef&&’ê’è_in(f.name,NATIVE_CLASSES)?c[d](f.name):(f instanceof AST_Array||f instanceof AST_Object||f instanceof AST_Call)&&(g=e(f))?c[d](g):void 0},f=e(d.return_annotation)))return f}return"?"}},AST_BaseCall),AST_ClassCall=DEFNODE("ClassCall","class super method static",{$documentation:"A function call expression",$propdoc:{class:"[string] name of the class method belongs to",super:"[boolean] this call can be replaced with a super() call",method:"[string] class method being called",static:"[boolean] defines whether the method is static"},_walk:function(a){var b;return b=this,a._visit(b,function(){var c,d,e,f,g,h,i;for(b.expression&&b.expression._walk(a),c=’ê’è_Iterable(b.args),d=0;d<c.length;d++)i=c[d],i._walk(a);for(e=’ê’è_Iterable(b.args.kwargs),f=0;f<e.length;f++)i=e[f],i[0]._walk(a),i[1]._walk(a);for(g=’ê’è_Iterable(b.args.kwarg_items),h=0;h<g.length;h++)i=g[h],i._walk(a)})}},AST_BaseCall),AST_New=DEFNODE("New",null,{$documentation:"An object instantiation. Derives from a function call since it has exactly the same properties"},AST_Call),AST_Seq=DEFNODE("Seq","car cdr",{$documentation:"A sequence expression (two comma-separated expressions)",$propdoc:{car:"[AST_Node] first element in sequence",cdr:"[AST_Node] second element in sequence"},$cons:function(a,b){var c;return c=new AST_Seq(a),c.car=a,c.cdr=b,c},$from_array:function(a){var b,c,d,e,f;if(0===a.length)return null;if(1===a.length)return a[0].clone();for(d=null,b=’ê’è_Iterable(range(a.length-1,-1,-1)),c=0;c<b.length;c++)e=b[c],d=AST_Seq.cons(a[e],d);for(f=d;f;){if(f.cdr&&!f.cdr.cdr){f.cdr=f.cdr.car;break}f=f.cdr}return d},to_array:function(){var a,b;for(a=this,b=[];a;){if(b.push(a.car),a.cdr&&!(a.cdr instanceof AST_Seq)){b.push(a.cdr);break}a=a.cdr}return b},add:function(a){var b,c;for(b=this;b;){if(!(b.cdr instanceof AST_Seq))return c=AST_Seq.cons(b.cdr,a),b.cdr=c;b=b.cdr}},_walk:function(a){var b;return b=this,a._visit(b,function(){b.car._walk(a),b.cdr&&b.cdr._walk(a)})}}),AST_PropAccess=DEFNODE("PropAccess","expression property",{$documentation:'Base class for property access expressions, i.e. `a.foo`, `a["foo"]` or a[1:5]',$propdoc:{expression:"[AST_Node] the ‚Äúcontainer‚Äù expression",property:"[AST_Node|string] the property to access. For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"}}),AST_Dot=DEFNODE("Dot",null,{$documentation:"A dotted property access expression",_walk:function(a){var b;return b=this,a._visit(b,function(){b.expression._walk(a)})},resolveType:function(a){var b;return b=this.expression.resolveType(a),b&&"{"===b[0]?/\{\w+:(.*)\}/.exec(b)[1]:"?"}},AST_PropAccess),AST_Sub=DEFNODE("Sub",null,{$documentation:'Index-style property access, i.e. `a["foo"]`',_walk:function(a){var b;return b=this,a._visit(b,function(){b.expression._walk(a),b.property._walk(a)})},resolveType:function(a){var b;if(b=this.expression.resolveType(a)){if("["===b[0]&&this.property instanceof AST_Number)return/\[(.*)\]/.exec(b)[1];if("{"===b[0])return/\{\w+:(.*)\}/.exec(b)[1]}return"?"}},AST_PropAccess),AST_Slice=DEFNODE("Slice","property2 assignment",{$documentation:"Index-style property access, i.e. `a[3:5]`",$propdoc:{property2:"[AST_Node] the 2nd property to access - typically ending index for the array.",assignment:"[AST_Node] The data being spliced in."},_walk:function(a){var b;return b=this,a._visit(b,function(){b.expression._walk(a),b.property._walk(a),b.property2._walk(a)})},resolveType:function(a){return this.expression.resolveType(a)}},AST_PropAccess),AST_Unary=DEFNODE("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.expression._walk(a)})},resolveType:function(a){return"!"===this.operator?"Boolean":’ê’è_in(this.operator,["-","+"])&&"Number"===this.expression.resolveType(a)?"Number":"?"}}),AST_UnaryPrefix=DEFNODE("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},AST_Unary),AST_UnaryPostfix=DEFNODE("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},AST_Unary),AST_Binary=DEFNODE("Binary","left operator right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.left._walk(a),b.right._walk(a)})},resolveType:function(a){var b,c;return this.left&&this.right?(b=this.left.resolveType(a),c=this.left.resolveType(a),"Number"===b&&"Number"===c?"Number":"Boolean"===b&&"Boolean"===c||’ê’è_in(this.operator,["===","!==",">",">=","<","<="])?"Boolean":"String"===b&&"+"===this.operator?"String":"?"):"?"}}),AST_Range=DEFNODE("Range",null,{$documentation:"Range node (to/til)",resolveType:function(a){return"[Number]"}},AST_Binary),AST_DeepEquality=DEFNODE("DeepEquality",null,{$documentation:"Pythonic deep equality operator",resolveType:function(a){return"Boolean"}},AST_Binary),AST_Conditional=DEFNODE("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_walk:function(a){var b;return b=this,a._visit(b,function(){b.condition._walk(a),b.consequent._walk(a),b.alternative._walk(a)})},resolveType:function(a){var b;return b=this.consequent.resolveType(a),b===this.alternative.resolveType(a)?b:"?"}}),AST_Assign=DEFNODE("Assign",null,{$documentation:"An assignment expression ‚Äî `a = b + 5`",resolveType:function(a){return"="===this.operator?this.right.resolveType(a):"?"}},AST_Binary),AST_Array=DEFNODE("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_walk:function(a){var b;return b=this,a._visit(b,function(){var c,d,e;for(c=’ê’è_Iterable(b.elements),d=0;d<c.length;d++)e=c[d],e._walk(a)})},resolveType:function(a){var b,c,d,e,f;if(!this.elements.length)return"[?]";for(d=this.elements[0].resolveType(a),b=’ê’è_Iterable(this.elements.slice(1)),c=0;c<b.length;c++)if(e=b[c],f=e.resolveType(a),f!==d)return 0===d.indexOf("Function")&&0===f.indexOf("Function")?"[Function]":"[?]";return"["+d+"]"}}),AST_TupleUnpack=DEFNODE("TupleUnpack","elements right",{$documentation:"An object used to represent tuple unpacking",$propdoc:{elements:"[AST_Node*] array of elements being assigned to",right:"[AST_Node] right-hand side expression"},_walk:function(a){var b;return b=this,a._visit(b,function(){var c,d,e;for(c=’ê’è_Iterable(b.elements),d=0;d<c.length;d++)e=c[d],e._walk(a);b.right._walk(a)})}}),AST_Object=DEFNODE("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[AST_ObjectProperty*] array of properties"},_walk:function(a){var b;return b=this,a._visit(b,function(){var c,d,e;for(c=’ê’è_Iterable(b.properties),d=0;d<c.length;d++)e=c[d],e._walk(a)})},resolveType:function(a){var b,c,d,e,f,g,h,i;if(!this.properties.length)return"{String:?}";for(d=0,e=null;this.properties[d]instanceof AST_UnaryPrefix;){if(e=this.properties[d].expression.resolveType(a),’ê’è_in("?",e))return"{String:?}";++d}for(f=this.properties[d].value.resolveType(a),b=’ê’è_Iterable(this.properties.slice(d+1)),c=0;c<b.length;c++)if(g=b[c],g instanceof AST_UnaryPrefix)if(e){if(e!==g.expression.resolveType(a))return"{String:?}"}else e=g.expression.resolveType(a);else if(g instanceof AST_Accessor);else if(h=g.value.resolveType(a),h!==f)return 0===f.indexOf("Function")&&0===h.indexOf("Function")?"{String:Function}":"{String:?}";return i="{String:"+f+"}",e?e===i?i:"{String:?}":i}}),AST_ObjectProperty=DEFNODE("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[AST_Node] the property name or expression for computed key ",value:"[AST_Node] property value. For setters and getters this is an AST_Function."},_walk:function(a){var b;return b=this,a._visit(b,function(){b.key._walk(a),b.value._walk(a)})}}),AST_ObjectKeyVal=DEFNODE("ObjectKeyVal",null,{$documentation:"A key: value object property"},AST_ObjectProperty),AST_ObjectSetter=DEFNODE("ObjectSetter",null,{$documentation:"An object setter property"},AST_Accessor),AST_ObjectGetter=DEFNODE("ObjectGetter",null,{$documentation:"An object getter property"
},AST_Accessor),AST_Symbol=DEFNODE("Symbol","scope name thedef",{$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},$documentation:"Base class for all symbols"}),AST_SymbolAlias=DEFNODE("SymbolAlias",null,{$documentation:"An alias used in an import statement"},AST_Symbol),AST_SymbolAccessor=DEFNODE("SymbolAccessor",null,{$documentation:"The name of a property accessor (setter/getter function)"},AST_Symbol),AST_SymbolDeclaration=DEFNODE("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",$propdoc:{init:"[AST_Node*/S] array of initializers for this declaration."}},AST_Symbol),AST_SymbolVar=DEFNODE("SymbolVar",null,{$documentation:"Symbol defining a variable"},AST_SymbolDeclaration),AST_SymbolNonlocal=DEFNODE("SymbolNonlocal",null,{$documentation:"A nonlocal declaration"},AST_SymbolDeclaration),AST_ImportedVar=DEFNODE("ImportedVar","alias",{$documentation:"Symbol defining an imported symbol",$propdoc:{alias:"AST_SymbolAlias the alias for this imported symbol"}},AST_SymbolVar),AST_SymbolConst=DEFNODE("SymbolConst",null,{$documentation:"A constant declaration"},AST_SymbolDeclaration),AST_SymbolFunarg=DEFNODE("SymbolFunarg","annotation",{$documentation:"Symbol naming a function argument",$propdoc:{annotation:"[AST_Annotation?] annotation provided for this argument, if any"}},AST_SymbolVar),AST_SymbolDefun=DEFNODE("SymbolDefun",null,{$documentation:"Symbol defining a function"},AST_SymbolDeclaration),AST_SymbolLambda=DEFNODE("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},AST_SymbolDeclaration),AST_SymbolCatch=DEFNODE("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},AST_SymbolDeclaration),AST_Label=DEFNODE("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LabelRef*] a list of nodes referring to this label"}},AST_Symbol),AST_SymbolRef=DEFNODE("SymbolRef","parens",{$documentation:"Reference to some symbol (not definition/declaration)",$propdoc:{parens:"[boolean/S] if true, this variable is wrapped in parentheses"},resolveType:function(a){var b,c,d;for(b=’ê’è_Iterable(reversed(a)),c=0;c<b.length;c++){if(d=b[c],’ê’è_in(this.name,d.vars))return d.vars[this.name][d.vars[this.name].length-1];if(d.args&&’ê’è_in(this.name,d.args))return d.args[this.name]}return"?"}},AST_Symbol),AST_SymbolClassRef=DEFNODE("SymbolClassRef","class",{$documentation:"Reference to class symbol",$propdoc:{class:"[AST_SymbolDeclaration?] the name of this class"}},AST_Symbol),AST_LabelRef=DEFNODE("LabelRef",null,{$documentation:"Reference to a label symbol"},AST_Symbol),AST_This=DEFNODE("This",null,{$documentation:"The `this` symbol"},AST_Symbol),AST_Constant=DEFNODE("Constant",null,{$documentation:"Base class for all constants",getValue:function(){return this.value}}),AST_String=DEFNODE("String","value modifier",{$documentation:"A string literal",$propdoc:{value:"[string] the contents of this string",modifier:"[string] string type modifier"},resolveType:function(){return"String"}},AST_Constant),AST_Verbatim=DEFNODE("Verbatim","value",{$documentation:"Raw JavaScript code",$propdoc:{value:"[string] A string of raw JS code"}},AST_Constant),AST_Number=DEFNODE("Number","value",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value"},resolveType:function(){return"Number"}},AST_Constant),AST_Identifier=DEFNODE("Identifier","value",{$documentation:"An identifier literal, used for unquoted property key",$propdoc:{value:"[string] the name of this key"},resolveType:function(){return"String"}},AST_Constant),AST_RegExp=DEFNODE("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"},resolveType:function(){return"RegExp"}},AST_Constant),AST_Atom=DEFNODE("Atom",null,{$documentation:"Base class for atoms"},AST_Constant),AST_Null=DEFNODE("Null",null,{$documentation:"The `null` atom",value:null,resolveType:function(){return null}},AST_Atom),AST_NaN=DEFNODE("NaN",null,{$documentation:"The impossible value",value:NaN,resolveType:function(){return null}},AST_Atom),AST_Undefined=DEFNODE("Undefined",null,{$documentation:"The `undefined` value",value:void 0,resolveType:function(){return null}},AST_Atom),AST_Hole=DEFNODE("Hole",null,{$documentation:"A hole in an array",value:void 0,resolveType:function(){return null}},AST_Atom),AST_Infinity=DEFNODE("Infinity",null,{$documentation:"The `Infinity` value",value:1/0,resolveType:function(){return"Number"}},AST_Atom),AST_Boolean=DEFNODE("Boolean",null,{$documentation:"Base class for booleans",resolveType:function(){return"Boolean"}},AST_Atom),AST_False=DEFNODE("False",null,{$documentation:"The `false` atom",value:!1},AST_Boolean),AST_True=DEFNODE("True",null,{$documentation:"The `true` atom",value:!0},AST_Boolean),TreeWalker.prototype={_visit:function(a,b){var c;return this.stack.push(a),c=this.visit(a,b?function(){b.call(a)}:noop),!c&&b&&b.call(a),this.stack.pop(),c},parent:function(a){return this.stack[this.stack.length-2-(a||0)]},push:function(a){this.stack.push(a)},pop:function(){return this.stack.pop()},self:function(){return this.stack[this.stack.length-1]},find_parent:function(a){var b,c,d,e,f;for(d=this.stack,b=’ê’è_Iterable(range(d.length-1,-1,-1)),c=0;c<b.length;c++)if(e=b[c],f=d[e],f instanceof a)return f},in_boolean_context:function(){var a,b,c,d;for(a=this.stack,b=a.length,c=a[--b];b>0;){if(d=a[--b],d instanceof AST_If&&d.condition===c||d instanceof AST_Conditional&&d.condition===c||d instanceof AST_DWLoop&&d.condition===c||d instanceof AST_UnaryPrefix&&"!"===d.operator&&d.expression===c)return!0;if(!(d instanceof AST_Binary)||"&&"!==d.operator&&"||"!==d.operator)return!1;c=d}},loopcontrol_target:function(a){var b,c,d,e,f,g,h;if(f=this.stack,a){for(b=’ê’è_Iterable(range(f.length-1,-1,-1)),c=0;c<b.length;c++)if(g=b[c],h=f[g],h instanceof AST_LabeledStatement&&h.label.name===a.name)return h.body}else for(d=’ê’è_Iterable(range(f.length-1,-1,-1)),e=0;e<d.length;e++)if(g=d[e],h=f[g],h instanceof AST_Switch||h instanceof AST_ForIn||h instanceof AST_DWLoop)return h}};function OutputStream(a){function t(a,b){return a.replace(/[\u0080-\uffff]/g,function(a){var c;if(c=a.charCodeAt(0).toString(16),c.length<=2&&!b){for(;c.length<2;)c="0"+c;return"\\x"+c}for(;c.length<4;)c="0"+c;return"\\u"+c})}function u(b,c){var d,e,b;return d=0,e=0,b=b.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g,function(a){var b;return b=a,"\\"===b?"\\\\":"\b"===b?"\\b":"\f"===b?"\\f":"\n"===b?"\\n":"\t"===b?"\\t":"\r"===b?"\\r":"\u2028"===b?"\\u2028":"\u2029"===b?"\\u2029":'"'===b?(++d,'"'):"'"===b?(++e,"'"):"\0"===b?"\\0":a}),a.ascii_only&&(b=t(b)),c?d>e?"'"+b.replace(/\x27/g,"\\'")+"'":'"'+b.replace(/\x22/g,'\\"')+'"':b}function v(b,c){var d;return d=u(b,c),a.inline_script&&(d=d.replace(/<\x2fscript([>\/\t\n\f\r ])/gi,"<\\/script$1")),d}function w(b){var b;return b=b.toString(),a.ascii_only&&(b=t(b,!0)),b}function x(c){return repeat_string(" ",a.indent_start+b-c*a.indent_level)}function y(){return j.charAt(j.length-1)}function z(){a.max_line_len&&c>a.max_line_len&&A("\n")}function A(b){var b,g,l,m,n,o;if(b=String(b),g=b.charAt(0),i&&(g&&’ê’è_in(g,";}")||/[;]$/.test(j)||(a.semicolons||k(g)?(f[f.length-1].output+=";",++c,++e):(f[f.length-1].output+="\n",++e,++d,c=0),a.beautify||(h=!1)),i=!1,z()),!a.beautify&&a.preserve_line&&s[s.length-1])for(l=s[s.length-1].start.line;d<l;)f[f.length-1].output+="\n",++e,++d,c=0,h=!1;h&&(m=y(),(is_identifier_char(m)&&(is_identifier_char(g)||"\\"===g)||/^[\+\-\/]$/.test(g)&&g===m)&&(f[f.length-1].output+=" ",++c,++e),h=!1),n=b.split(/\r?\n/),o=n.length-1,d+=o,0===o?c+=n[o].length:c=n[o].length,e+=b.length,j=b,f[f.length-1].output+=b}function B(){i=!1,A(";")}function C(){return b+a.indent_level}function D(){var a,b,c,d,e;for(a=’ê’è_Iterable(enumerate(arguments)),b=0;b<a.length;b++)c=a[b],d=c[0],e=c[1],d>0&&l(),e.print?e.print(this):A(e)}function E(a,b){return function(c){var d;d=this,d.print("Object.defineProperty("),d.print(c),d.comma(),d.print_string(a),d.comma(),d.with_block(function(){d.indent(),d.print("value"),d.colon(),d.print_string(b),d.newline()}),d.print(")")}}function F(a,b){return function(c){var d;d=this,d.print("Object.defineProperties("),d.print(c),a&&d.print("."+a),d.comma(),d.with_block(function(){Object.keys(b).forEach(function(a,c){c&&(d.print(","),d.newline()),d.indent(),d.print(a),d.colon(),d.with_block(function(){var c,e,f;for(c=’ê’è_Iterable(["enumerable","writable"]),e=0;e<c.length;e++)f=c[e],d.indent(),d.print(f),d.colon(),d.print("true"),d.comma(),d.newline();d.indent(),d.print("value"),d.colon(),b[a](d)})}),d.newline()}),d.print(")")}}function G(){p(),o()}function H(a){var b;return b=null,A("{"),o(),n(C(),function(){b=a()}),m(),A("}"),b}function I(a){var b;return A("("),b=a(),A(")"),b}function J(a){var b;return A("["),b=a(),A("]"),b}function K(){A(","),l()}function L(){A(":"),a.space_colon&&l()}function M(){if(f.len>1)throw new Error("Something went wrong, output generator didn't exit all of its scopes properly.");return f[0].vars.length&&(f.unshift({vars:[],output:""}),R()),f[0].output}function N(a){"string"==typeof a?A(a):a.print(this),l(),A("="),l()}function O(a,b){a=void 0===a?"_":a,b=void 0===b||b;var c;return++r[a],c=RAPYD_PREFIX+a+r[a],b&&f[f.length-1].vars.push(c),c}function P(a){return a=void 0===a?"_":a,RAPYD_PREFIX+a+r[a]}function Q(){f.push({vars:[],output:""})}function R(){var a;a=f.pop(),a.vars.length&&(m(),A("var "),a.vars.forEach(function(a,b){b&&K(),A(a)}),G()),f[f.length-1].output+=a.output}var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s;return a=defaults(a,{indent_start:0,indent_level:4,quote_keys:!1,space_colon:!0,ascii_only:!1,inline_script:!1,width:80,max_line_len:32e3,ie_proof:!0,es6:!1,beautify:!1,source_map:null,bracketize:!1,semicolons:!0,comments:!1,preserve_line:!1,omit_baselib:!1,baselib:null,private_scope:!0,auto_bind:!1,write_name:!0},!0),b=0,c=0,d=1,e=0,f=[{vars:[],output:""}],g={},h=!1,i=!1,j=null,k=makePredicate("( [ + * / - , ."),l=a.beautify?function(){A(" ")}:function(){h=!0},m=a.beautify?function(b){a.beautify&&A(x(b?.5:0))}:noop,n=a.beautify?function(a,c){var a,d,e;return a===!0&&(a=C()),d=b,b=a,e=c(),b=d,e}:function(a,b){return b()},o=a.beautify?function(){A("\n")}:noop,p=a.beautify?function(){A(";")}:function(){i=!0},q=a.source_map?function(b,e){try{b&&a.source_map.add(b.file||"?",d,c,b.line,b.col,e||"name"!==b.type?e:b.value)}catch(a){AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} ‚Üí {cline},{ccol} [{name}]",{file:b.file,line:b.line,col:b.col,cline:d,ccol:c,name:e||""})}}:noop,r={itr:0,idx:0,upk:0,_:0},s=[],{get:M,toString:M,indent:m,indentation:function(){return b},current_width:function(){return c-b},should_break:function(){return a.width&&this.current_width()>=a.width},newline:o,print:A,space:l,comma:K,colon:L,last:function(){return j},semicolon:p,force_semicolon:B,to_ascii:t,print_name:function(a){A(w(a))},print_string:function(a,b){b=void 0===b||b,A(v(a,b))},next_indent:C,with_indent:n,with_block:H,with_parens:I,spaced:D,end_statement:G,addProperty:E,startLocalBuffer:Q,endLocalBuffer:R,addProperties:F,with_square:J,add_mapping:q,assign:N,get_baselib:function(b){return a.omit_baselib?null:a.baselib[b]},import:function(a){return!g.hasOwnProperty(a)&&(g[a]=a,!0)},is_main:function(){return 1===f.length&&0===f[f.length-1].output.length},option:function(b){return a[b]},line:function(){return d},col:function(){return c},pos:function(){return e},push_node:function(a){s.push(a)},pop_node:function(){return s.pop()},stack:function(){return s},newTemp:O,prevTemp:P,parent:function(a){return s[s.length-2-(a||0)]}}}!function(){function c(a,b){var c,c=[].slice.call(arguments,2);return c=c.filter(function(a){return null!==a}),function(d){return c.length?function(){var e;e=a.newTemp(),b&&a.assign(b),a.with_parens(function(){var b,f,g;for(a.assign(e),d(),a.comma(),b=’ê’è_Iterable(c),f=0;f<b.length;f++)g=b[f],null!==g&&(g.call(a,e),a.comma());a.print(e)}),b&&a.semicolon()}:function(){d()}}}function d(a,b){a.DEFMETHOD("_codegen",b)}function e(a,b){a.DEFMETHOD("needs_parens",b)}function f(a){var b;return b=a.parent(),b instanceof AST_Unary||(b instanceof AST_Binary&&!(b instanceof AST_Assign)||(b instanceof AST_BaseCall&&b.expression===this||(b instanceof AST_Conditional&&b.condition===this||(b instanceof AST_PropAccess&&b.expression===this||void 0))))}function g(a,b,c){var d;d=a.length-1,a.forEach(function(a,e){a instanceof AST_EmptyStatement||a instanceof AST_Definitions||(c.indent(),a.print(c),e===d&&b||c.newline())})}function h(a,b){var c;for(c in a)b.indent(),b.print("this."),b.assign(c),b.print("’ê’è_bind"),b.with_parens(function(){b.print("this."+c),b.comma(),b.print("this")}),b.end_statement()}function i(a,b){var c,d,e,f,g,h,i,j,k,l,m,n,p,a,q;for(m=[],c=’ê’è_Iterable(Object.keys(a.imports)),d=0;d<c.length;d++)n=c[d],m.push(a.imports[n]);for(m.sort(function(a,b){var c,a,b;return c=[a.import_order,b.import_order],a=c[0],b=c[1],a<b?-1:a>b?1:0}),m.length>1&&(b.indent(),b.spaced("var ’ê’è_modules","=","{};"),b.newline()),p={},e=’ê’è_Iterable(m),f=0;f<e.length;f++)for(a=e[f],g=’ê’è_Iterable(a.nonlocalvars),h=0;h<g.length;h++)q=g[h],p[q]=!0;for(p=Object.getOwnPropertyNames(p).join(", "),p.length&&(b.indent(),b.print("var "+p),b.end_statement()),i=’ê’è_Iterable(m),j=0;j<i.length;j++)a=i[j],"__main__"!==a.module_id&&(b.indent(),b.assign('’ê’è_modules["'+a.module_id+'"]'),b.print("{}"),b.end_statement());for(k=’ê’è_Iterable(m),l=0;l<k.length;l++)a=k[l],"__main__"!==a.module_id&&o(a,b)}function j(a){a.option("write_name")&&(a.newline(),a.indent(),a.spaced("var __name__","=",'"__main__"'),a.end_statement())}function k(a,b,c){var d,e;if(c.startLocalBuffer(),d=0,!(a instanceof AST_Method)||a.static||c.option("es6")&&"__init__"===a.name.name||(c.indent(),c.spaced("var",a.argnames[0],"=","this"),c.end_statement(),++d),a instanceof AST_Scope){if(a.argnames&&(a.argnames.starargs&&(c.indent(),c.spaced("var",a.argnames.starargs,"=","[].slice.call"),c.with_parens(function(){c.print("arguments"),c.comma(),c.print(a.argnames.length-d)}),c.end_statement()),!c.option("es6")))for(e in a.argnames.defaults)c.indent(),c.spaced(e,"=",e,"===","void 0","?"),c.space(),w(a.argnames.defaults[e],c),c.space(),c.colon(),c.print(e),c.end_statement();c.option("auto_bind")&&a.name&&"__init__"===a.name.name&&(c.indent(),c.print("’ê’è_rebindAll"),c.with_parens(function(){c.print("this"),c.comma(),c.print("true")}),c.end_statement(),h(a.bound,c)),l(a.localvars,c)}else a instanceof AST_Except&&a.argname&&(c.indent(),c.print("var "),c.assign(a.argname),c.print("’ê’è_Exception"),c.end_statement());g(a.body,b,c),c.endLocalBuffer()}function l(a,b){a.length&&(b.indent(),b.print("var "),a.forEach(function(a,c){c&&b.comma(),a.print(b)}),b.end_statement())}function m(a,b,c,d){var e,f,g,h,i,j,k,l;for(i={},e=’ê’è_Iterable(b),f=0;f<e.length;f++)j=e[f],d.newline(),d.indent(),d.print('’ê’è_modules["'+a+'"]["'+j.name+'"] = '+j.name),i[j.name]=!0,d.end_statement();for(g=’ê’è_Iterable(c),h=0;h<g.length;h++)k=g[h],i.hasOwnProperty(a)||(l=k.split(".")[k.split(".").length-1],d.newline(),d.indent(),d.print('’ê’è_modules["'+a+'"]["'+l+'"] = '),d.print('’ê’è_modules["'+k+'"]'),d.end_statement())}function n(a,b,c){a.elements.forEach(function(d,e){b.indent(),b.assign(d),b.print(b.prevTemp("upk")),b.with_square(function(){b.print(e)}),(!c||e<a.elements.length-1)&&b.end_statement()})}function o(a,b){b.newline(),b.indent(),b.with_parens(function(){b.print("function()"),b.with_block(function(){b.indent(),b.assign("var __name__"),b.print('"'+a.module_id+'"'),b.end_statement(),l(a.localvars,b),g(a.body,!0,b),m(a.module_id,a.exports,a.submodules,b)})}),b.print("()"),b.end_statement()}function p(a,b,c){a.body.length?b.with_block(function(){c?k(a,!1,b):g(a.body,!1,b)}):b.print("{}")}function q(a){return a.object instanceof AST_BaseCall&&a.object.expression instanceof AST_SymbolRef&&"dir"===a.object.expression.name&&1===a.object.args.length}function r(a){return a.object instanceof AST_BaseCall&&a.object.expression instanceof AST_SymbolRef&&"range"===a.object.expression.name&&!(a.init instanceof AST_Array)&&(a.object.args.length<3||a.object.args[a.object.args.length-1][0]instanceof AST_Number||a.object.args[a.object.args.length-1][0]instanceof AST_Unary&&"-"===a.object.args[a.object.args.length-1][0].operator&&a.object.args[a.object.args.length-1][0].expression instanceof AST_Number)}function s(a,b,c){var d,e;d=0,(e=function(){d<a.length?(a[d].expression.print(b),++d,b.with_parens(function(){e()})):c()})()}function u(a,b){var c;if(b.option("bracketize"))return void B(a.body,b);if(!a.body)return b.force_semicolon();if(a.body instanceof AST_Do&&b.option("ie_proof"))return void B(a.body,b);for(c=a.body;;)if(c instanceof AST_If){if(!c.alternative)return void B(a.body,b);c=c.alternative}else{if(!(c instanceof AST_StatementWithBody))break;c=c.body}w(a.body,b)}function v(a,b,c){if(c)try{a.walk(new TreeWalker(function(a){if(a instanceof AST_Binary&&"in"===a.operator)throw b})),a.print(b)}catch(c){var d=c;if(d!==b)throw d;a.print(b,!0)}else a.print(b)}function w(a,b){b.option("bracketize")?!a||a instanceof AST_EmptyStatement?b.print("{}"):a instanceof AST_BlockStatement?a.print(b):b.with_block(function(){b.indent(),a.print(b),b.newline()}):!a||a instanceof AST_EmptyStatement?b.force_semicolon():a.print(b)}function x(a){var b,c,d,e;for(b=a.stack(),c=b.length,d=b[--c],e=b[--c];c>0;){if(e instanceof AST_Statement&&e.body===d)return!0;if(!(e instanceof AST_Seq&&e.car===d||e instanceof AST_BaseCall&&e.expression===d||e instanceof AST_Dot&&e.expression===d||e instanceof AST_Sub&&e.expression===d||e instanceof AST_Conditional&&e.condition===d||e instanceof AST_Binary&&e.left===d||e instanceof AST_UnaryPostfix&&e.expression===d))return!1;d=e,e=b[--c]}}function y(a,b){return 0===a.args.length&&!b.option("beautify")}function z(a){var b,c,d;for(b=a[0],c=b.length,d=1;d<a.length;d++)a[d].length<c&&(b=a[d],c=b.length);return b}function A(a){var b,c,d;return b=a.toString(10),c=[b.replace(/^0\./,".").replace("e+","e")],d=null,Math.floor(a)===a?(a>=0?c.push("0x"+a.toString(16).toLowerCase(),"0"+a.toString(8)):c.push("-0x"+(-a).toString(16).toLowerCase(),"-0"+(-a).toString(8)),(d=/^(.*?)(0+)$/.exec(a))&&c.push(d[1]+"e"+d[2].length)):(d=/^0?\.(0+)(.*)$/.exec(a))&&c.push(d[2]+"e-"+(d[1].length+d[2].length),b.substr(b.indexOf("."))),z(c)}function B(a,b){return a instanceof AST_BlockStatement?void a.print(b):void b.with_block(function(){b.indent(),a.print(b),b.newline()})}function C(a,b){a.DEFMETHOD("add_source_map",function(a){b(this,a)})}function D(a,b){b.add_mapping(a.start)}var a,b;a={bind:"’ê’è_bind",rebind_all:"’ê’è_rebindAll",bool:"!!",float:"parseFloat",int:"parseInt",mixin:"’ê’è_mixin",merge:"’ê’è_merge",print:"’ê’è_print",eslice:"’ê’è_eslice",type:"’ê’è_type"},AST_Node.DEFMETHOD("print",function(a,b){var c,d;c=this,d=c._codegen,a.push_node(c),b||c.needs_parens(a)?a.with_parens(function(){c.add_comments(a),c.add_source_map(a),d(c,a)}):(c.add_comments(a),c.add_source_map(a),d(c,a)),a.pop_node()}),AST_Node.DEFMETHOD("print_to_string",function(a){var b;return b=OutputStream(a),this.print(b),b.get()}),AST_Node.DEFMETHOD("add_comments",function(a){var b,c,d,e;b=a.option("comments"),c=this,b&&(d=c.start,d&&!d._comments_dumped&&(d._comments_dumped=!0,e=d.comments_before,c instanceof AST_Exit&&c.value&&c.value.start.comments_before.length>0&&(e=(e||[]).concat(c.value.start.comments_before),c.value.start.comments_before=[]),b.test?e=e.filter(function(a){return b.test(a.value)}):"function"==typeof b&&(e=e.filter(function(a){return b(c,a)})),e.forEach(function(b){"comment:line"===b.type?(a.print("//"+b.value+"\n"),a.indent()):"comment:multiline"===b.type&&(a.print("/*"+b.value+"*/"),d.newline_before?(a.print("\n"),a.indent()):a.space())})))}),e(AST_Node,function(){return!1}),e(AST_Function,function(a){return x(a)}),e(AST_Object,function(a){return x(a)}),e(AST_Unary,function(a){var b;return b=a.parent(),b instanceof AST_PropAccess&&b.expression===this}),e(AST_Seq,function(a){var b;return b=a.parent(),b instanceof AST_Unary||b instanceof AST_VarDef||b instanceof AST_Dot||b instanceof AST_ObjectProperty||b instanceof AST_Conditional}),e(AST_Range,function(a){return!1}),e(AST_Binary,function(a){var b,c,d,e,f;return b=a.parent(),b instanceof AST_BaseCall&&b.expression===this||(b instanceof AST_Unary||(b instanceof AST_PropAccess&&b.expression===this||(b instanceof AST_Binary&&(c=b.operator,d=PRECEDENCE[c],e=this.operator,f=PRECEDENCE[e],d>f||d===f&&this===b.right&&(e!==c||"*"!==e&&"&&"!==e&&"||"!==e))||void 0)))}),e(AST_PropAccess,function(a){var b;if(b=a.parent(),b instanceof AST_New&&b.expression===this)try{this.walk(new TreeWalker(function(a){if(a instanceof AST_BaseCall)throw b}))}catch(a){var c=a;if(c!==b)throw c;return!0}}),e(AST_BaseCall,function(a){var b;return b=a.parent(),b instanceof AST_New&&b.expression===this}),e(AST_New,function(a){var b;if(b=a.parent(),y(this,a)&&(b instanceof AST_PropAccess||b instanceof AST_BaseCall&&b.expression===this))return!0}),e(AST_Number,function(a){var b;if(b=a.parent(),this.getValue()<0&&b instanceof AST_PropAccess&&b.expression===this)return!0}),e(AST_NaN,function(a){var b;if(b=a.parent(),b instanceof AST_PropAccess&&b.expression===this)return!0}),e(AST_Assign,f),e(AST_Conditional,f),d(AST_Directive,function(a,b){b.print_string(a.value),b.semicolon()}),d(AST_Debugger,function(a,b){b.print("debugger"),b.semicolon()}),AST_StatementWithBody.DEFMETHOD("_do_print_body",function(a){w(this.body,a)}),d(AST_Statement,function(a,b){a.body.print(b),b.semicolon()}),d(AST_Toplevel,function(a,b){var c;c=b.is_main(),b.option("private_scope")&&c?(b.with_parens(function(){b.print("function()"),b.with_block(function(){b.indent(),b.print('"use strict"'),b.end_statement(),Object.keys(a.baselib).forEach(function(a){var c;c=b.get_baselib(a),c&&c.print(b)}),i(a,b),b.newline(),b.indent(),b.with_parens(function(){b.print("function()"),b.with_block(function(){j(b),b.newline(),k(a,!0,b),b.newline()})}),b.print("();"),b.newline()})}),b.print("();"),b.print("")):(c&&(Object.keys(a.baselib).forEach(function(a){var c;c=b.get_baselib(a),c&&c.print(b)}),i(a,b),j(b)),a.strict&&l(a.localvars,b),g(a.body,!0,b))}),d(AST_Splat,function(a,b){b.import(a.module.name)&&(g(a.body.body,!0,b),b.newline())}),d(AST_Imports,function(a,b){function k(a,c,d){b.assign("var "+a),b.print('’ê’è_modules["'+c+'"]'),d&&b.print("."+d),b.end_statement(),b.indent()}var c,d,e,f,g,h,i,j;for(c=’ê’è_Iterable(a.imports),d=0;d<c.length;d++)if(g=c[d],b.import(g.module.name),g.argnames)for(e=’ê’è_Iterable(g.argnames),f=0;f<e.length;f++)h=e[f],i=h.alias?h.alias.name:h.name,k(i,g.key,h.name);else g.alias?k(g.alias.name,g.key,!1):(j=g.key.split(".",1)[0],k(j,j,!1))}),d(AST_LabeledStatement,function(a,b){a.label.print(b),b.colon(),a.body.print(b)}),d(AST_SimpleStatement,function(a,b){a.body instanceof AST_EmptyStatement||(a.body.print(b),b.semicolon())}),d(AST_BlockStatement,function(a,b){p(a,b)}),d(AST_EmptyStatement,function(a,b){}),d(AST_Do,function(a,b){b.print("do"),b.space(),a._do_print_body(b),b.space(),b.print("while"),b.space(),b.with_parens(function(){a.condition.print(b)}),b.semicolon()}),d(AST_While,function(a,b){b.print("while"),b.space(),b.with_parens(function(){a.condition.print(b)}),b.space(),a._do_print_body(b)}),AST_ForIn.DEFMETHOD("_do_print_body",function(a){var b;b=this,a.with_block(function(){var c,d,e;r(b)||q(b)||(a.indent(),c=a.prevTemp("itr"),d=a.prevTemp("idx"),b.init instanceof AST_Array?a.option("es6")?(a.with_square(function(){b.init.elements.forEach(function(b,c){c&&a.comma(),b.print(a)})}),a.space(),a.print("="),a.space(),a.print(c+"["+d+"];"),a.newline()):(e=a.newTemp("upk"),a.assign(e),a.print(c+"["+d+"];"),a.newline(),n(b.init,a)):(a.assign(b.init),a.print(c+"["+d+"];"),a.newline())),b.body.body.forEach(function(b,c){a.indent(),b.print(a),a.newline()})})}),d(AST_ForIn,function(a,b){var c,d,e,f,g,h;r(a)?(c=null,d=a.object.args,e=d.length,1===e?(f=0,g=d[0]):2===e?(f=d[0],g=d[1]):3===e&&(f=d[0],g=d[1],c=d[2]),b.print("for"),b.space(),b.with_parens(function(){b.assign(a.init),f.print?f.print(b):b.print(f),b.semicolon(),b.space(),a.init.print(b),b.space(),c instanceof AST_Unary?b.print(">"):b.print("<"),b.space(),g.print(b),b.semicolon(),b.space(),a.init.print(b),!c||c instanceof AST_Unary&&"1"===c.expression.value?c instanceof AST_Unary?b.print("--"):b.print("++"):c instanceof AST_Unary?(b.print("-="),c.expression.print(b)):(b.print("+="),c.print(b))})):q(a)?(b.print("for"),b.space(),b.with_parens(function(){b.spaced(a.init,"in",a.object.args[0])})):(h=b.newTemp("itr"),b.assign(h),b.print("’ê’è_Iterable"),b.with_parens(function(){a.object.print(b)}),b.end_statement(),b.indent(),b.print("for"),b.space(),b.with_parens(function(){var a;a=b.newTemp("idx"),b.assign(a),b.print("0"),b.semicolon(),b.space(),b.spaced(a,"<",h+".length"),b.semicolon(),b.space(),b.print(a+"++")})),b.space(),a._do_print_body(b)}),AST_ForJS.DEFMETHOD("_do_print_body",function(a){var b;b=this,a.with_block(function(){b.body.body.forEach(function(b,c){a.indent(),b.print(a),a.newline()})})}),d(AST_ForJS,function(a,b){b.print("for"),b.space(),b.with_parens(function(){a.condition.print(b)}),b.space(),a._do_print_body(b)}),d(AST_ListComprehension,function(a,b){var c,d,e,f,g;c={ListComprehension:"[]",DictComprehension:"{}"}[a.TYPE],d=b.newTemp("itr",!1),e=b.newTemp("idx",!1),f=RAPYD_PREFIX+"res",g=a instanceof AST_DictComprehension?function(){b.indent(),b.print(f),b.with_square(function(){a.statement.print(b)}),b.assign(""),a.value_statement.print(b),b.end_statement()}:function(){b.indent(),b.print(f+".push"),b.with_parens(function(){a.statement.print(b)}),b.end_statement()},b.with_parens(function(){b.print("function"),b.print("()"),b.space(),b.with_block(function(){b.indent(),b.print("var "+e),b.comma(),b.assign(d),b.print("’ê’è_Iterable"),b.with_parens(function(){a.object.print(b)}),b.comma(),b.assign(f),b.print(c),a.init instanceof AST_Array?a.init.elements.forEach(function(a){b.comma(),a.print(b)}):(b.comma(),a.init.print(b)),b.semicolon(),b.newline(),b.indent(),b.print("for"),b.space(),b.with_parens(function(){b.spaced(e,"=","0"),b.semicolon(),b.space(),b.spaced(e,"<",d+".length"),b.semicolon(),b.space(),b.print(e+"++")}),b.space(),b.with_block(function(){b.indent(),a.init instanceof AST_Array?(b.option("es6")?(b.with_square(function(){a.left.elements.forEach(function(a,c){c&&b.comma(),a.print(b)})}),b.comma(),b.print("="),b.comma()):b.assign(b.newTemp("upk")),b.print(d+"["+e+"];"),b.newline(),b.option("es6")||n(a.init,b)):(b.assign(a.init),b.print(d+"["+e+"];"),b.newline()),a.condition?(b.indent(),b.print("if"),b.space(),b.with_parens(function(){a.condition.print(b)}),b.space(),b.with_block(function(){g()}),b.newline()):g()}),b.newline(),b.indent(),b.print("return "+f),b.end_statement()})}),b.print("()")}),d(AST_With,function(a,b){b.print("with"),b.space(),b.with_parens(function(){a.expression.print(b)}),b.space(),a._do_print_body(b)}),AST_Lambda.DEFMETHOD("_do_print",function(a,b){function g(){return e.decorators&&e.decorators.length?function(a){var b;b=this,b.assign(a),s(e.decorators,b,function(){b.print(a)})}:null}function h(){return e.docstring?function(a){var b;b=this,b.addProperty("__doc__",e.docstring).call(b,a)}:null}var d,e,f;e=this,f=null,e.name&&(f="var "+e.name.name);var i=(d=function(){b||(a.print("function"),e.generator&&a.print("*")),e.name&&(a.space(),e.name.print(a)),a.with_parens(function(){e.argnames.forEach(function(b,c){c&&a.comma(),b.print(a),a.option("es6")&&e.argnames.defaults[b.name]&&(a.print("="),e.argnames.defaults[b.name].print(a))}),e.kwargs&&(e.argnames.length&&a.comma(),a.print("’ê’è_kw"))}),a.space(),p(e,a,!0)},d=c(a,f,g(),h())(d));i()}),d(AST_Lambda,function(a,b){a._do_print(b)}),AST_Class.DEFMETHOD("_do_print",function(a){function k(){return f.decorators&&f.decorators.length?function(a){var b;b=this,b.assign(a),s(f.decorators,b,function(){b.print(a)})}:null}function l(){var b;return b={},f.docstring&&(b.__doc__=function(a){a.print_string(f.docstring)}),f.body.forEach(function(a,c){a instanceof AST_SimpleStatement&&a.body instanceof AST_Assign&&"="===a.body.operator&&(b[a.body.left.name]=function(b){a.body.right.print(b),b.newline()})}),Object.keys(b).length?a.addProperties("prototype",b):null}function n(a){return function(b){function d(){b.print("function"),b.space(),b.print(c),b.with_parens(function(){a.argnames.forEach(function(a,d){var d;’ê’è_in(c,f.static)&&++d,d>1&&b.comma(),d&&a.print(b)}),f.kwargs&&(f.argnames.length&&b.comma(),b.print("’ê’è_kw"))}),p(a,b,!0)}var c;c=a.name.name,a.decorators&&a.decorators.length?s(a.decorators,b,d):d(),b.newline()}}function o(){return f.parent?function(a){var b;b=this,b.print("’ê’è_extends"),b.with_parens(function(){b.print(a),b.comma(),f.parent.print(b)})}:null}function q(){var b,c,d,e;return b={},c={},f.docstring&&(b.__doc__=function(a){a.print_string(f.docstring)}),f.body.forEach(function(a,d){a instanceof AST_Method?a.static?c[a.name.name]=n(a):b[a.name.name]=n(a):a instanceof AST_Class&&console.error("Nested classes aren't supported yet")}),d=null,Object.keys(b).length&&(d=a.addProperties("prototype",b)),e=null,Object.keys(c).length&&(e=a.addProperties(null,c)),[d,e]}var b,d,e,f,g,i,j;if(f=this,!f.external){if(g=null,f.name&&(g="var "+f.name.name),a.option("es6"))var m=(b=function(){a.print("class"),f.name&&(a.space(),f.name.print(a)),f.parent&&(a.space(),a.print("extends"),a.space(),f.parent.print(a)),a.space(),a.with_block(function(){f.body.forEach(function(b,c){b instanceof AST_Lambda&&(a.indent(),b.static&&(a.print("static"),a.space()),"__init__"===b.name.name?a.print("constructor"):(b instanceof AST_ObjectGetter?a.print("get "):b instanceof AST_ObjectSetter&&a.print("set "),b.name.print(a)),a.space(),a.with_parens(function(){b.argnames.forEach(function(b,c){var c;’ê’è_in(g,f.static)&&++c,c>1&&a.comma(),c&&b.print(a)}),f.kwargs&&(f.argnames.length&&a.comma(),a.print("’ê’è_kw"))}),a.space(),p(b,a,!0),a.newline())})})},b=c(a,g,k(),l())(b));else{d=q(),i=d[0],j=d[1];var m=(e=function(){f.init||f.parent||f.statements.length?(a.print("function"),a.space(),f.name.print(a),a.print("()"),a.space(),a.with_block(function(){var b;h(f.bound,a),f.statements.forEach(function(b){a.indent(),b.print(a),a.newline()}),(f.init||f.parent)&&(a.indent(),b=f.init?f.name:f.parent,b.print(a),a.print(".prototype.__init__.apply"),a.with_parens(function(){a.print("this"),a.comma(),a.print("arguments")}),a.end_statement())})):(a.print("function"),a.space(),f.name.print(a),a.print("()"),a.space(),a.with_block(function(){h(f.bound,a)}))},e=c(a,g,o(),k(),i,j)(e))}m()}}),d(AST_Class,function(a,b){a._do_print(b)}),d(AST_SymbolClassRef,function(a,b){a.class.print(b),b.print(".prototype."+a.name)}),AST_Exit.DEFMETHOD("_do_print",function(a,b){var c;c=this,a.print(b),c.value&&(a.space(),c.value.print(a)),a.semicolon()}),d(AST_Return,function(a,b){a._do_print(b,"return")}),d(AST_Yield,function(a,b){a._do_print(b,"yield")}),d(AST_Throw,function(a,b){a._do_print(b,"throw")}),AST_LoopControl.DEFMETHOD("_do_print",function(a,b){a.print(b),this.label&&(a.space(),this.label.print(a)),a.semicolon()}),d(AST_Break,function(a,b){a._do_print(b,"break")}),d(AST_Continue,function(a,b){a._do_print(b,"continue")}),d(AST_If,function(a,b){b.print("if"),b.space(),b.with_parens(function(){a.condition.print(b)}),b.space(),a.alternative?(u(a,b),b.space(),b.print("else"),b.space(),w(a.alternative,b)):a._do_print_body(b)}),d(AST_Switch,function(a,b){b.print("switch"),b.space(),b.with_parens(function(){a.expression.print(b)}),b.space(),a.body.length>0?b.with_block(function(){a.body.forEach(function(a,c){c&&b.newline(),b.indent(!0),a.print(b)})}):b.print("{}")}),AST_SwitchBranch.DEFMETHOD("_do_print_body",function(a){this.body.length>0&&(a.newline(),this.body.forEach(function(b){a.indent(),b.print(a),a.newline()}))}),d(AST_Default,function(a,b){b.print("default:"),a._do_print_body(b)}),d(AST_Case,function(a,b){b.print("case"),b.space(),a.expression.print(b),b.print(":"),a._do_print_body(b)}),d(AST_Try,function(a,b){b.print("try"),b.space(),p(a,b),a.bcatch&&(b.space(),a.bcatch.print(b)),a.bfinally&&(b.space(),a.bfinally.print(b))}),d(AST_Catch,function(a,b){b.print("catch"),b.space(),b.with_parens(function(){b.print("’ê’è_Exception")}),b.space(),a.body.length>1||a.body[0].errors.length?b.with_block(function(){var c;b.indent(),c=!0,a.body.forEach(function(a,c){var d;c&&b.print("else "),a.errors.length?(b.print("if"),b.space(),b.with_parens(function(){a.errors.forEach(function(a,c){c&&(b.newline(),b.indent(),b.print("||"),b.space()),b.spaced("’ê’è_Exception","instanceof",a)})}),b.space()):d=!1,p(a,b,!0),b.space()}),c&&(b.print("else"),b.space(),b.with_block(function(){b.indent(),b.spaced("throw","’ê’è_Exception"),b.end_statement()})),b.newline()}):p(a.body[0],b,!0)}),d(AST_Finally,function(a,b){b.print("finally"),b.space(),p(a,b)}),AST_Definitions.DEFMETHOD("_do_print",function(a,b){var c,d,e;a.print(b),a.space(),this.definitions.forEach(function(b,c){c&&a.comma(),b.print(a)}),c=a.parent(),d=c instanceof AST_ForIn,e=d&&c.init===this,e||a.semicolon()}),d(AST_Var,function(a,b){a._do_print(b,"var")}),d(AST_Const,function(a,b){a._do_print(b,"const")}),d(AST_VarDef,function(a,b){a.name.print(b),a.value&&(b.assign(""),v(a.value,b,b.parent(1)instanceof AST_ForIn))}),b=[],d(AST_BaseCall,function(c,d){function l(){var b;c instanceof AST_ClassCall?c.static?(c.class.print(d),d.print("."+c.method)):d.option("es6")&&c.super?(d.print("super"),"constructor"!==c.method&&d.print("."+c.method),e=c.args.shift()):(c.class.print(d),d.print(".prototype."+c.method+".call")):(b=’ê’è_in(c.expression.name,a)?a[c.expression.name]:void 0,b?d.print(b):c.expression.print(d))}var e,f,g,h,i,j,k;return e=null,c instanceof AST_New&&(f=b.pop(),y(c,d))?void l():(g=c.args.kwarg_items&&c.args.kwarg_items.length,h=c.args.kwargs&&c.args.kwargs.length,i=g||h,c.args.starargs||i?(j=c instanceof AST_New?f:c.expression.expression?c.expression.expression:new AST_This,d.option("es6")?i?(d.print("kwargs"),d.with_parens(function(){l()})):l():c instanceof AST_New?(l(),d.semicolon(),d.newline(),d.indent(),i?(d.print("kwargs"),d.with_parens(function(){f.print(d),d.print(".__init__")})):(f.print(d),d.print(".__init__"))):i?(d.print("kwargs"),d.with_parens(function(){l()})):l()):l(),k=function(){g&&(c.args.kwarg_items.forEach(function(a,b){b>0&&(d.print(","),d.space()),a.print(d)}),h&&(d.print(","),d.space())),h&&(d.print("{"),c.args.kwargs.forEach(function(a,b){b&&d.comma(),a[0].print(d),d.print(":"),d.space(),a[1].print(d)}),d.print("}"))},d.option("es6")&&c.args.starargs?d.with_parens(function(){c.args.forEach(function(a,b){b&&d.comma(),c.args.starargs&&b===c.args.length-1&&d.print("..."),a.print(d)})}):c.args.starargs?(d.print(".apply"),d.with_parens(function(){j.print(d),d.comma(),c.args.length>1?d.with_square(function(){c.args.slice(0,-1).forEach(function(a,b){b&&d.comma(),a.print(d)})}):c.args[0].print(d),(i||c.args.length>1)&&(d.print(".concat"),d.with_parens(function(){c.args.length>1&&(c.args[c.args.length-1].print(d),i&&d.comma()),k()}))})):i&&(c instanceof AST_New||c.expression&&c.expression.expression)?(d.print(".call"),d.with_parens(function(){var a,b,e;for(j.print(d),a=’ê’è_Iterable(c.args),b=0;b<a.length;b++)e=a[b],d.comma(),e.print(d);d.comma(),k()})):d.with_parens(function(){c.args.forEach(function(a,b){b&&d.comma(),a.print(d)}),i&&(c.args.length&&d.comma(),k())}),void(d.option("es6")&&c instanceof AST_ClassCall&&c.super&&(d.end_statement(),d.indent(),d.spaced("var",e,"=","this"))))}),d(AST_New,function(a,b){b.print("new"),b.space(),AST_BaseCall.prototype._codegen(a,b)}),AST_Seq.DEFMETHOD("_do_print",function(a){var b,c,d;b=this,c=a.parent(),d=function(){b.car.print(a),b.cdr&&(a.comma(),a.should_break()&&(a.newline(),a.indent()),b.cdr.print(a))},c instanceof AST_Binary||c instanceof AST_Return||c instanceof AST_Array||c instanceof AST_BaseCall||c instanceof AST_SimpleStatement?a.with_square(d):d()}),d(AST_Seq,function(a,b){a._do_print(b)}),d(AST_Dot,function(a,b){var c;c=a.expression,c.print(b),c instanceof AST_Number&&c.getValue()>=0&&(/[xa-f.]/i.test(b.last())||b.print(".")),b.print("."),b.add_mapping(a.end),b.print_name(a.property)}),d(AST_Sub,function(a,b){a.expression.print(b),b.print("["),a.property instanceof AST_Unary&&"-"===a.property.operator&&a.property.expression instanceof AST_Number&&(a.expression.print(b),b.print(".length")),a.property.print(b),b.print("]")}),d(AST_Slice,function(a,b){b.print("[].splice.apply"),b.with_parens(function(){a.expression.print(b),b.comma(),b.with_square(function(){a.property.print(b),b.comma(),a.property2.print(b),b.print("-"),a.property.print(b)}),b.print(".concat"),b.with_parens(function(){a.assignment.print(b)})})}),d(AST_UnaryPrefix,function(a,b){var c;c=a.operator,"*"===c&&(c="..."),b.print(c),/^[a-z]/i.test(c)&&b.space(),a.expression.print(b)}),d(AST_UnaryPostfix,function(a,b){a.expression.print(b),b.print(a.operator)}),d(AST_Binary,function(a,b){var c,d,e,f,g;c={"<":!0,">":!0,"<=":!0,">=":!0,"==":!0,"!=":!0},d={in:"’ê’è_in","**":"Math.pow","//":"Math.floor"},e=function(a){return"=="===a?"===":"!="===a?"!==":a},’ê’è_in(a.operator,d)?(b.print(d[a.operator]),b.with_parens(function(){a.left.print(b),"//"===a.operator?(b.space(),b.print("/"),b.space()):b.comma(),a.right.print(b)})):c[a.operator]&&a.left instanceof AST_Binary&&c[a.left.operator]?(f=e(a.operator),a.left.right instanceof AST_Symbol?(a.left.print(b),g=a.left.right.name):(a.left.left.print(b),b.space(),b.print(a.left.operator),b.space(),b.with_parens(function(){g=b.newTemp(),b.assign(g),a.left.right.print(b)})),b.space(),b.spaced("&&",g,f,a.right)):b.spaced(a.left,e(a.operator),a.right)}),d(AST_DeepEquality,function(a,b){function d(a){var c;return a instanceof AST_SymbolRef||a instanceof AST_SymbolClassRef?(a.print(b),a):(c=b.newTemp(),b.with_parens(function(){b.spaced(c,"=",a)}),{print:function(a){a.print(c)}})}var c;c=["Boolean","String","Number"],’ê’è_in(a.left.computedType,c)||’ê’è_in(a.right.computedType,c)?(a.left.print(b),b.space(),"=="===a.operator?b.print("==="):b.print("!=="),b.space(),a.right.print(b)):b.with_parens(function(){
var c,e;c=d(a.left),"=="===a.operator?(b.space(),b.spaced("==="),b.space(),e=d(a.right),b.space(),b.spaced("||","typeof",c,"===",'"object"'),b.space(),b.print("&&"),b.space(),b.print("’ê’è_eq"),b.with_parens(function(){c.print(b),b.comma(),e.print(b)})):(b.space(),b.spaced("!=="),b.space(),e=d(a.right),b.space(),b.print("&&"),b.space(),b.with_parens(function(){b.spaced("typeof",c,"!==",'"object"'),b.space(),b.print("||"),b.space(),b.print("!’ê’è_eq"),b.with_parens(function(){c.print(b),b.comma(),e.print(b)})}))})}),d(AST_Assign,function(a,c){if(a.right instanceof AST_Number&&1===a.right.value&&’ê’è_in(a.operator,["+=","-="]))c.print("+="===a.operator?"++":"--"),a.left.print(c);else{if("//="===a.operator)return c.assign(a.left),c.print("Math.floor"),void c.with_parens(function(){a.left.print(c),c.space(),c.print("/"),c.space(),a.right.print(c)});a.left instanceof AST_Array?c.option("es6")?c.with_square(function(){a.left.elements.forEach(function(a,b){b&&c.comma(),a.print(c)})}):c.print(c.newTemp("upk")):a.left.print(c),c.space(),c.print(a.operator),c.space(),a.right instanceof AST_New&&b.push(a.left),a.right.print(c),a.left instanceof AST_Array&&(c.option("es6")||(c.end_statement(),n(a.left,c,!0)))}}),d(AST_Conditional,function(a,b){a.condition.print(b),b.space(),b.print("?"),b.space(),a.consequent.print(b),b.space(),b.colon(),a.alternative.print(b)}),d(AST_Array,function(a,b){b.with_square(function(){var c,d;c=a.elements,d=c.length,d>0&&b.space(),c.forEach(function(a,c){c&&b.comma(),a.print(b)}),d>0&&b.space()})}),d(AST_Range,function(a,b){var c,d,e,f,g,h,i;for(e=[],c=’ê’è_Iterable([a.left,a.right]),d=0;d<c.length;d++)f=c[d],f instanceof AST_UnaryPrefix&&"-"===f.operator&&f.expression instanceof AST_Number?e.push(parseFloat("-"+f.expression.value)):f instanceof AST_Number?e.push(parseFloat(f.value)):e.push(null);e[0]&&e[1]&&Math.abs(e[1]-e[0])<50?(g=e[0],h=e[1],i=g<h?1:-1,"to"===a.operator&&(h+=i/1e6),b.with_square(function(){var a,c,d;for(a=’ê’è_Iterable(range(g,h,i)),c=0;c<a.length;c++)d=a[c],d!==g&&b.comma(),b.print(d)})):(b.print("range"),b.with_parens(function(){a.left.print(b),b.comma(),"to"===a.operator?b.spaced(a.left,"<",a.right,"?",a.right,"+",1e-6,":",a.right,"-",1e-6):a.right.print(b),b.comma(),b.spaced(a.left,"<",a.right,"?","1",":","-1")}))}),d(AST_Object,function(a,b){a.properties.length>0?b.with_block(function(){a.properties.forEach(function(a,c){c&&(b.print(","),b.newline()),b.indent(),a.print(b)}),b.newline()}):b.print("{}")}),d(AST_ObjectKeyVal,function(a,b){a.key instanceof AST_Identifier||a.key instanceof AST_String||a.key instanceof AST_Number||a.key instanceof AST_Boolean?a.key.print(b):b.with_square(function(){a.key.print(b)}),b.colon(),a.value.print(b)}),AST_Symbol.DEFMETHOD("definition",function(){return this.thedef}),d(AST_Symbol,function(a,b){var c;c=a.definition(),b.print_name(c?c.mangled_name||c.name:a.name)}),d(AST_Undefined,function(a,b){b.print("void 0")}),d(AST_Hole,noop),d(AST_Infinity,function(a,b){b.print("1/0")}),d(AST_NaN,function(a,b){b.print("0/0")}),d(AST_This,function(a,b){b.print("this")}),d(AST_Constant,function(a,b){b.print(a.getValue())}),d(AST_String,function(a,b){’ê’è_in(a.modifier,"fF")?(b.print("`"),b.print_string(a.getValue(),!1),b.print("`")):b.print_string(a.getValue())}),d(AST_Verbatim,function(a,b){b.print(a.getValue())}),d(AST_Number,function(a,b){b.print(A(a.getValue()))}),d(AST_RegExp,function(a,b){var c,d;c=a.getValue().toString(),b.option("ascii_only")&&(c=b.to_ascii(c)),b.print(c),d=b.parent(),d instanceof AST_Binary&&/^in/.test(d.operator)&&d.left===a&&b.print(" ")}),C(AST_Node,noop),C(AST_Directive,D),C(AST_Debugger,D),C(AST_Symbol,D),C(AST_Jump,D),C(AST_StatementWithBody,D),C(AST_LabeledStatement,noop),C(AST_Lambda,D),C(AST_Switch,D),C(AST_SwitchBranch,D),C(AST_BlockStatement,D),C(AST_Toplevel,noop),C(AST_New,D),C(AST_Try,D),C(AST_Catch,D),C(AST_Finally,D),C(AST_Definitions,D),C(AST_Constant,D),C(AST_ObjectProperty,function(a,b){b.add_mapping(a.start,a.key)})}();function is_letter(a){return a>=97&&a<=122||a>=65&&a<=90||a>=170&&UNICODE.letter.test(String.fromCharCode(a))}function is_digit(a){return a>=48&&a<=57}function is_alphanumeric_char(a){return is_digit(a)||is_letter(a)}function is_unicode_combining_mark(a){return UNICODE.non_spacing_mark.test(a)||UNICODE.space_combining_mark.test(a)}function is_unicode_connector_punctuation(a){return UNICODE.connector_punctuation.test(a)}function is_string_modifier(a){var b,c,d;for(b=’ê’è_Iterable(a),c=0;c<b.length;c++)if(d=b[c],’ê’è_in(d,STRING_MODIFIERS))return!0;return!1}function is_identifier(a){return!RESERVED_WORDS(a)&&IDENTIFIER_PAT.test(a)}function is_identifier_start(a){return 36===a||95===a||is_letter(a)}function is_identifier_char(a){var b;return b=a.charCodeAt(0),is_identifier_start(b)||is_digit(b)||8204===b||8205===b||is_unicode_combining_mark(a)||is_unicode_connector_punctuation(a)}function parse_js_number(a){return RE_HEX_NUMBER.test(a)?parseInt(a.substr(2),16):RE_OCT_NUMBER.test(a)?parseInt(a.substr(1),8):RE_DEC_NUMBER.test(a)?parseFloat(a):void 0}function js_error(a,b,c,d,e,f){throw AST_Node.warn("ERROR:¬†{message}¬†[{file}:{line},{col}]",{message:a,file:b,line:c,col:d}),new ParseError(a,c,d,e,f)}function is_token(a,b,c){return a.type===b&&(null===c||void 0===c||a.value===c)}function tokenizer(a,b){function g(){return c.text.charAt(c.pos)}function h(){return c.text.charAt(c.tokpos-1)}function i(a,b){var d;if(d=c.text.charAt(c.pos),++c.pos,a&&!d)throw EX_EOF;return"\n"===d?(c.newline_before=c.newline_before||!b,++c.line,c.col=0):++c.col,d}function j(a,b){var d;if(d=c.text.indexOf(a,c.pos),b&&d===-1)throw EX_EOF;return d}function k(){c.tokline=c.line,c.tokcol=c.col,c.tokpos=c.pos}function l(a,d,e,f){var a,g,h,d,i,k;if(a=a.split(":"),g=a[0],h=a[1],c.regex_allowed="operator"===g&&!UNARY_POSTFIX[d]||"keyword"===g&&KEYWORDS_BEFORE_EXPRESSION(d)||"punc"===g&&PUNC_BEFORE_EXPRESSION(d),"operator"===g&&"is"===d&&"not"===c.text.substr(c.pos).trimLeft().substr(0,4).trimRight()&&(A(),d="!=="),"operator"===g&&OP_MAP[d]&&(d=OP_MAP[d]),i={type:g,subtype:h,value:d,line:c.tokline,col:c.tokcol,pos:c.tokpos,endpos:c.pos,newline_before:c.newline_before,file:b},!e)for(i.comments_before=c.comments_before,c.comments_before=[],k=0;k<len(i.comments_before);k++)i.newline_before=i.newline_before||i.comments_before[k].newline_before;return f||(c.newline_before=!1),"punc"===g&&(":"!==d||c.index_or_slice[c.index_or_slice.length-1]||c.expect_object_literal_key||c.text.substring(c.pos+1,j("\n")).trim()&&c.text.substring(c.pos+1,j("#")).trim()||(c.newblock=!0,c.indentation_matters.push(!0)),"["===d?(c.prev&&"name"===c.prev.type?c.index_or_slice.push(!0):c.index_or_slice.push(!1),c.indentation_matters.push(!1)):"{"===d||"("===d?c.indentation_matters.push(!1):"]"===d?(c.index_or_slice.pop(),c.indentation_matters.pop()):"}"!==d&&")"!==d||c.indentation_matters.pop()),c.prev=new AST_Token(i),c.prev}function m(){var a,b,d;for(a="",b=!1;WHITESPACE_CHARS(g());)b=!0,d=i(),"\n"===d?a="":a+=d;if("#"!==g()&&(b?c.cached_whitespace=a:a=c.cached_whitespace,c.newline_before||c.endblock))return n(a)}function n(a){var b;return b=c.whitespace_before[c.whitespace_before.length-1]||"",c.endblock=!1,c.indentation_matters[c.indentation_matters.length-1]&&a!==b?c.newblock&&a&&0===a.indexOf(b)?(c.newblock=!1,c.whitespace_before.push(a),1):b&&0===b.indexOf(a)?(c.endblock=!0,c.whitespace_before.pop(),-1):void p("Inconsistent indentation"):0}function o(a){var b,c,d;for(b="",c=0;(d=g())&&a(d,c);)++c,b+=i();return b}function p(a,d){js_error(a,b,c.tokline,c.tokcol,c.tokpos,d)}function q(a){var b,c,d,e,f,g;return b=!1,c=!1,d=!1,e="."===a,f=o(function(b,d){var e,f,g,h,i;return e=b.charCodeAt(0),f=e,120===f||88===f?!g&&(g=!0):101===f||69===f?!!g||!h&&(h=c=!0):45===f?c||0===d&&!a:43===f?c:46===f?(c=!1,!(i||g||h)&&(i=!0)):is_alphanumeric_char(e)}),a&&(f=a+f),g=parse_js_number(f),isNaN(g)?void p("Invalid syntax: "+f):l("num",g)}function r(a,b){var b,c,d;return b=b||function(a){return i(!0,a)},c=b(a),d=c.charCodeAt(0),110===d?"\n":114===d?"\r":116===d?"\t":98===d?"\b":118===d?"\v":102===d?"\f":48===d?"\0":120===d?String.fromCharCode(s(2,b)):117===d?String.fromCharCode(s(4,b)):10===d?"":c}function s(a,b){var c,d,e;for(c=0,d=0;d<a;d++)e=parseInt(b(),16),isNaN(e)&&p("Invalid hex-character pattern in string"),c=c<<4|e;return c}function t(a){a=void 0!==a&&a;var b,d;return a||i(),b=j("\n"),b===-1?(d=c.text.substr(c.pos),c.pos=c.text.length):(d=c.text.substring(c.pos,b),c.pos=b),l(a?"shebang":"comment:line",d,!0)}function u(){var a,b,d,e,f;for(a=!1,b="",d=!1;null!==(e=g());)if(a)"u"!==e&&p("Expecting UnicodeEscapeSequence -- uXXXX"),e=r(),is_identifier_char(e)||p("Unicode char: "+e.charCodeAt(0)+" is not valid in identifier"),b+=e,a=!1;else if("\\"===e){if("\n"===c.text.charAt(c.pos+1)){c.pos+=2;continue}d=a=!0,i()}else{if(!is_identifier_char(e))break;b+=i()}return KEYWORDS(b)&&d&&(f=b.charCodeAt(0).toString(16).toUpperCase(),b="\\u"+"0000".substr(f.length)+f+b.slice(1)),b}function v(a){function c(a){var b;return g()?(b=a+g(),OPERATORS(b)?(i(),c(b)):a):a}var b;if(b=c(a||i()),’ê’è_in(b,["++","--","===","!=="]))p("Invalid operator ¬´"+b+"¬ª");else if("->"===b)return l("punc",b);return l("operator",b)}function w(){return i(),c.regex_allowed?f(""):v("/")}function x(){return i(),is_digit(g().charCodeAt(0))?q("."):l("punc",".")}function y(){var a;return a=u(),KEYWORDS_ATOM(a)?l("atom",a):KEYWORDS(a)?OPERATORS(a)&&"."!==h()?l("operator",a):l("keyword",a):l("name",a)}function z(a,b){return function(c){try{return b(c)}catch(b){var d=b;if(d!==EX_EOF)throw b;p(a,!0)}}}function A(a){var b,e,h,j,n,o,r,s;return ’ê’è_in(a,[null,void 0])?(b=m(),b===-1?l("punc","}",!1,!0):(k(),(e=g())?(h=e.charCodeAt(0),j=h,34===j||39===j?d():35===j?0===c.pos&&"!"===c.text.charAt(1)?t(!0):(n=c.regex_allowed,c.comments_before.push(t()),c.regex_allowed=n,A()):46===j?x():47===j?w():is_digit(h)?q():PUNC_CHARS(e)?l("punc",i()):OPERATOR_CHARS(e)?v():92===h&&"\n"===c.text.charAt(c.pos+1)?(i(),i(),c.newline_before=!1,A()):92===h||is_identifier_start(h)?(o=y(),’ê’è_in(g(),"'\"")&&is_string_modifier(o.value)&&(r=o.value.toLowerCase(),s=d(r),o.endpos=s.endpos,o.value=s.value,o.subtype=s.subtype,o.type=s.type),o):void p("Unexpected character ¬´"+e+"¬ª")):l("eof"))):f(a)}var c,d,e,f;return c={text:a.replace(/\r\n?|[\n\u2028\u2029]/g,"\n").replace(/\uFEFF/g,""),filename:b,pos:0,tokpos:0,line:1,tokline:0,col:0,tokcol:0,newline_before:!1,regex_allowed:!1,comments_before:[],whitespace_before:[],newblock:!1,endblock:!1,indentation_matters:[!0],cached_whitespace:"",prev:void 0,index_or_slice:[!1],expect_object_literal_key:!1},d=z("Unterminated string constant",function(a){var b,d,e,f,h,k,m;if(b="string",a&&(b+=":"+a),d=i(),e="",g()===d){if(i(!0),g()!==d)return l(b,"");if(i(!0),f=j(d+d+d,!0),f!==-1){for(h=c.text.substring(c.pos,f),c.pos=f+3;h.length;)"\\"===h[0]?(h=h.slice(1),e+=r(!0,function(){var a;return a=h[0],h=h.slice(1),a})):(e+=h[0],h=h.slice(1));return k=e.match(/\n/g),k&&(c.line+=k.length),l(b,e)}}for(;;){if(m=i(!0),"\n"===m&&p("End of line while scanning string literal."),"\\"===m){if("\n"===g()){i(!0);continue}m=r(!0)}else if(m===d)break;e+=m}return l(b,e)}),e=z("Unterminated multiline comment",function(){var a,b,d,e;return i(),a=j("*/",!0),b=c.text.substring(c.pos,a),d=b.split("\n"),e=d.length,c.pos=a+2,c.line+=e-1,e>1?c.col=d[e-1].length:c.col+=d[e-1].length,c.col+=2,c.newline_before=c.newline_before||’ê’è_in("\n",b),l("comment:multiline",b,!0)}),f=z("Unterminated regular expression",function(a){var b,c,d,e,f,h,a;if(b=!1,c=!1,d=!1,e=!1,"/"===g()){if(i(!0),"/"!==g())return f=u(),l("regexp",new RegExp(a,f));d=!0,i(!0)}for(;h=i(!0);)if(e)"\n"===h&&(e=!1);else if(b)a+="\\"+h,b=!1;else if("["===h)c=!0,a+=h;else if("]"===h&&c)c=!1,a+=h;else{if("/"===h&&!c){if(d){if("/"!==g()){a+="\\/";continue}if(i(!0),"/"!==g()){a+="\\/\\/";continue}i(!0)}break}"\\"===h?b=!0:d&&!c&&’ê’è_in(h," \n\r\t")||(d&&!c&&"#"===h?e=!0:a+=h)}return f=u(),l("regexp",new RegExp(a,f))}),A.context=function(a){return a&&(c=a),c},A}var ES6_KEYWORDS,KEYWORDS,KEYWORDS_ATOM,RESERVED_WORDS,KEYWORDS_BEFORE_EXPRESSION,ALL_KEYWORDS,OPERATOR_CHARS,RE_HEX_NUMBER,RE_OCT_NUMBER,RE_DEC_NUMBER,OPERATORS,OP_MAP,WHITESPACE_CHARS,PUNC_BEFORE_EXPRESSION,PUNC_CHARS,REGEXP_MODIFIERS,UNICODE,IDENTIFIER_PAT,STRING_MODIFIERS,UNARY_POSTFIX,EX_EOF;ES6_KEYWORDS="async await yield",KEYWORDS="as break case class const continue debugger default def del do elif else except finally for from if import in instanceof is new nonlocal pass raise return switch til to try typeof var void while with or and not "+ES6_KEYWORDS,KEYWORDS_ATOM="False None True",RESERVED_WORDS="abstract boolean byte char double enum export extends final float goto implements int interface long native package private protected public short static synchronized this throws transient volatile "+KEYWORDS_ATOM+" "+KEYWORDS,KEYWORDS_BEFORE_EXPRESSION="return new del raise elif else if",ALL_KEYWORDS=RESERVED_WORDS+" "+KEYWORDS_BEFORE_EXPRESSION,KEYWORDS=makePredicate(KEYWORDS),ES6_KEYWORDS=makePredicate(ES6_KEYWORDS),RESERVED_WORDS=makePredicate(RESERVED_WORDS),KEYWORDS_BEFORE_EXPRESSION=makePredicate(KEYWORDS_BEFORE_EXPRESSION),KEYWORDS_ATOM=makePredicate(KEYWORDS_ATOM),OPERATOR_CHARS=makePredicate(characters("+-*&%=<>!?|~^@")),RE_HEX_NUMBER=/^0x[0-9a-f]+$/i,RE_OCT_NUMBER=/^0[0-7]+$/,RE_DEC_NUMBER=/^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i,OPERATORS=makePredicate(["in","instanceof","typeof","new","void","del","++","--","+","-","not","~","&","|","^","**","*","/","//","%",">>","<<",">>>","<",">","<=",">=","==","===","is","!=","!==","?","=","+=","-=","/=","//=","*=","%=",">>=","<<=",">>>=","|=","^=","&=","and","or","til","to","@","->"]),OP_MAP={or:"||",and:"&&",not:"!",del:"delete",None:"null",is:"==="},WHITESPACE_CHARS=makePredicate(characters(" ¬†\n\r\t\f\v‚Äã·†é‚ÄÄ‚ÄÅ‚ÄÇ‚ÄÉ‚ÄÑ‚ÄÖ‚ÄÜ‚Äá‚Äà‚Äâ‚Ää‚ÄØ‚Åü„ÄÄ")),PUNC_BEFORE_EXPRESSION=makePredicate(characters("[{(,.;:")),PUNC_CHARS=makePredicate(characters("[]{}(),;:")),REGEXP_MODIFIERS=makePredicate(characters("gmsiy")),UNICODE={letter:new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),non_spacing_mark:new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),space_combining_mark:new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),connector_punctuation:new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")},IDENTIFIER_PAT=/^[a-z_$][_a-z0-9$]*$/i,STRING_MODIFIERS="urfURF",UNARY_POSTFIX=makePredicate(["--","++"]),EX_EOF={};var RAPYD_PREFIX, NATIVE_CLASSES, COMMON_STATIC, CLASS_MAP, BASELIB, STDLIB, UNARY_PREFIX, ASSIGNMENT, PRECEDENCE, STATEMENTS_WITH_LABELS, ATOMIC_START_TOKEN;RAPYD_PREFIX = "’ê’è";NATIVE_CLASSES = { "Image": {}, "RegExp": {}, "Error": {}, "Object": { static: [ "assign", "getOwnPropertyNames", "keys", "create", "defineProperty", "defineProperties", "getPrototypeOf", "setPrototypeOf" ] }, "String": { static: [ "fromCharCode" ] }, "Array": { static: [ "isArray", "from", "of" ] }, "Number": { static: [ "isFinite", "isNaN" ] }, "Function": {}, "Date": { static: [ "UTC", "now", "parse" ] }, "Boolean": {}, "ArrayBuffer": {}, "DataView": {}, "Float32Array": {}, "Float64Array": {}, "Int16Array": {}, "Int32Array": {}, "Int8Array": {}, "Uint16Array": {}, "Uint32Array": {}, "Uint8Array": {}, "Uint8ClampedArray": {}, "Map": {}, "WeakMap": {}, "Set": {}, "WeakSet": {}, "AssertionError": {}, "IndexError": {}, "KeyError": {}, "TypeError": {}, "ValueError": {}};COMMON_STATIC = [ "call", "apply", "bind", "toString" ];CLASS_MAP = {};BASELIB = {};STDLIB = [ "abs", "bin", "cmp", "chr", "dir", "hex", "max", "min", "merge", "mixin", "print", "range", "reduce", "getattr", "setattr", "hasattr", "eq", "bind", "rebind_all", "type", "all", "any", "enumerate", "filter", "len", "map", "reversed", "sum", "zip", "AssertionError", "IndexError", "KeyError", "TypeError", "ValueError" ];function has_simple_decorator(decorators, name) { var remove, s; remove = []; for (var i = 0; i < decorators.length; i++) { s = decorators[i]; if (s instanceof AST_SymbolRef && !s.parens && s.name === name) { remove.push(i); } } if (remove.length) { remove.reverse(); for (var i = 0; i < remove.length; i++) { decorators.splice(remove[i], 1); } return true; } return false;}UNARY_PREFIX = makePredicate([ "typeof", "void", "delete", "--", "++", "!", "~", "-", "+", "*", "@" ]);ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "//=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ]);PRECEDENCE = function(a, ret) { var i, b, j; for (i = 0; i < a.length; i++) { b = a[i]; for (j = 0; j < b.length; j++) { ret[b[j]] = i + 1; } } return ret;}([ [ "||" ], [ "&&" ], [ "|" ], [ "^" ], [ "&" ], [ "==", "===", "!=", "!==" ], [ "<", ">", "<=", ">=", "in", "instanceof" ], [ ">>", "<<", ">>>" ], [ "+", "-" ], [ "*", "/", "//", "%" ], [ "**" ] ], {});STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ]);ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ]);function parse($TEXT, options) { var ’ê’èitr1, ’ê’èidx1, ’ê’è_1, ’ê’è_2, ’ê’è_3, ’ê’è_4; var options, module_id, import_dirs, IMPORTED, IMPORTING, S, cname, obj; options = defaults(options, { strict: false, filename: null, auto_bind: false, module_id: "__main__", es6: false, toplevel: null, import_dirs: [], dropDecorators: [], dropImports: [], classes: null }); module_id = options.module_id; import_dirs = options.import_dirs.slice(0); if (options.libdir) { import_dirs.push(options.libdir); } if (options.basedir) { import_dirs.unshift(options.basedir); } IMPORTED = options.IMPORTED || {}; IMPORTING = options.IMPORTING || {}; IMPORTING[module_id] = true; S = { input: typeof $TEXT === "string" ? tokenizer($TEXT, options.filename) : $TEXT, token: null, prev: null, peeked: null, in_directives: true, in_loop: 0, in_scope: [ { type: null, vars: {}, nonlocal: {}, functions: {}, classes: {} } ], labels: [], decorators: [], in_seq: false, in_decorator: false }; if (options.classes) { ’ê’èitr1 = ’ê’è_Iterable(options.classes); for (’ê’èidx1 = 0; ’ê’èidx1 < ’ê’èitr1.length; ’ê’èidx1++) { cname = ’ê’èitr1[’ê’èidx1]; obj = options.classes[cname]; S.in_scope[0].classes[cname] = { "static": obj.static, "bound": obj.bound }; } } S.token = next(); function is_(type, value) { return is_token(S.token, type, value); } function peek() { return S.peeked || (S.peeked = S.input()); } function next() { S.prev = S.token; if (S.peeked) { S.token = S.peeked; S.peeked = null; } else { S.token = S.input(); } S.in_directives = S.in_directives && (S.token.type === "string" || is_("punc", ";")); return S.token; } function prev() { return S.prev; } function croak(msg, line, col, pos, is_eof) { var ctx; ctx = S.input.context(); js_error(msg, ctx.filename, line !== void 0 ? line : ctx.tokline, col !== void 0 ? col : ctx.tokcol, pos !== void 0 ? pos : ctx.tokpos, is_eof); } function token_error(token, msg) { var is_eof; is_eof = token.type === "eof" ? true : false; croak(msg, token.line, token.col, void 0, is_eof); } function unexpected(token) { var token; if (token === void 0) { token = S.token; } token_error(token, "Unexpected token: " + token.type + " ¬´" + token.value + "¬ª"); } function expect_token(type, val) { if (is_(type, val)) { return next(); } token_error(S.token, "Unexpected token " + S.token.type + " ¬´" + S.token.value + "¬ª" + ", expected " + type + " ¬´" + val + "¬ª"); } function expect(punc) { return expect_token("punc", punc); } function can_insert_semicolon() { return !options.strict && (S.token.newline_before || is_("eof") || is_("punc", "}")); } function semicolon() { if (is_("punc", ";")) { next(); S.token.newline_before = true; } } function parenthesised() { var exp; expect("("); exp = expression(true); expect(")"); return exp; } function embed_tokens(parser) { return function() { var start, expr, end; start = S.token; expr = parser(); if (expr === void 0) { unexpected(); } end = prev(); expr.start = start; expr.end = end; return expr; }; } var is_nested_comparison = (’ê’è_1 = function is_nested_comparison(stmt) { var comparators; comparators = { "<": true, ">": true, "<=": true, ">=": true, "==": true, "!=": true, "===": true, "!==": true }; if (stmt instanceof AST_Binary && ’ê’è_in(stmt.operator, comparators) && stmt.left instanceof AST_Binary && ’ê’è_in(stmt.left.operator, comparators)) { return true; } else { return false; } }, Object.defineProperty(’ê’è_1, "__doc__", { value: "Check if the statement is a nested comparison" }), ’ê’è_1); function scan_for_top_level_callables(body) { var ’ê’èitr2, ’ê’èidx2; var ans, name, obj, x, opt; ans = []; if (Array.isArray(body)) { for (name in body) { obj = body[name]; if (obj instanceof AST_Function || obj instanceof AST_Class) { if (obj.name) { ans.push(obj.name); } else { token_error(obj.start, "Top-level functions must have names"); } } else { if (obj instanceof AST_Scope) { continue; } ’ê’èitr2 = ’ê’è_Iterable([ "body", "alternative" ]); for (’ê’èidx2 = 0; ’ê’èidx2 < ’ê’èitr2.length; ’ê’èidx2++) { x = ’ê’èitr2[’ê’èidx2]; opt = obj[x]; if (opt) { ans = ans.concat(scan_for_top_level_callables(opt)); } if (opt instanceof AST_Assign && !(opt.right instanceof AST_Scope)) { ans = ans.concat(scan_for_top_level_callables(opt.right)); } } } } } else if (body.body) { ans = ans.concat(scan_for_top_level_callables(body.body)); if (body.alternative) { ans = ans.concat(scan_for_top_level_callables(body.alternative)); } } return ans; } var statement = (’ê’è_2 = function statement() { var tmp_, dir, stat, type, start, func, chain, ctor, result, expectedType, actualType, tmp; if (is_("operator", "/") || is_("operator", "/=")) { S.peeked = null; S.token = S.input(S.token.value.slice(1)); } tmp_ = S.token.type; if (tmp_ === "string") { dir = S.in_directives; stat = simple_statement(); if (dir && stat.body instanceof AST_String && !is_("punc", ",")) { return new AST_Directive({ value: stat.body.value }); } return stat; } else if (tmp_ === "shebang") { tmp_ = S.token.value; next(); return new AST_Directive({ value: tmp_ }); } else if (tmp_ === "num" || tmp_ === "regexp" || tmp_ === "operator" || tmp_ === "atom") { return simple_statement(); } else if (tmp_ === "punc") { tmp_ = S.token.value; if (tmp_ === ":") { return new AST_BlockStatement({ start: S.token, body: block_(), end: prev() }); } else if (tmp_ === "{" || tmp_ === "[" || tmp_ === "(") { return simple_statement(); } else if (tmp_ === ";") { next(); return new AST_EmptyStatement(); } else { unexpected(); } } else if (tmp_ === "name") { if (’ê’è_in(S.token.value, [ "set", "get" ])) { if (!options.es6) { croak("Class getters/setters require ES6 compilation mode"); } type = S.token.value; start = S.token.start; next(); return accessor_(type, start, true); } return is_token(peek(), "punc", ":") ? labeled_statement() : simple_statement(); } else if (tmp_ === "keyword") { tmp_ = S.token.value; if (ES6_KEYWORDS(tmp_) && !options.es6) { token_error(prev(), "¬´" + tmp_ + "¬ª keyword not supported with ES5 output, use --ecmascript6 compilation flag"); } next(); if (tmp_ === "break") { return break_cont(AST_Break); } else if (tmp_ === "continue") { return break_cont(AST_Continue); } else if (tmp_ === "debugger") { semicolon(); return new AST_Debugger(); } else if (tmp_ === "do") { return new AST_Do({ body: in_loop(statement), condition: function() { var tmp; expect("."); expect_token("keyword", "while"); tmp = expression(true); semicolon(); return tmp; }.call(this) }); } else if (tmp_ === "while") { return new AST_While({ condition: expression(true), body: in_loop(statement) }); } else if (tmp_ === "for") { if (is_("name", "JS")) { return for_js(); } return for_(); } else if (tmp_ === "from") { return import_(true); } else if (tmp_ === "import") { return import_(false); } else if (tmp_ === "class") { BASELIB["extends"] = true; if (options.auto_bind) { BASELIB["rebind_all"] = true; BASELIB["bind"] = true; } return class_(); } else if (tmp_ === "def") { start = prev(); func = function_(S.in_scope[S.in_scope.length-1].type === "class" ? S.in_scope[S.in_scope.length-1].name : false); func.start = start; func.end = prev(); chain = subscripts(func, true); if (chain === func) { return func; } else { return new AST_SimpleStatement({ start: start, body: chain, end: prev() }); } } else if (tmp_ === "if") { return if_(); } else if (tmp_ === "pass") { semicolon(); return new AST_EmptyStatement(); } else if (tmp_ === "return" || tmp_ === "yield") { if (S.in_scope[S.in_scope.length-1].type !== "function") { croak("'return' outside of function"); } if (tmp_ === "yield") { S.in_scope[S.in_scope.length-1].generator = true; ctor = AST_Yield; } else { ctor = AST_Return; } result = new ctor({ value: is_("punc", ";") ? function() { semicolon(); return null; }() : can_insert_semicolon() ? null : function() { var tmp; tmp = expression(true); semicolon(); return tmp; }() }); if (S.in_scope[S.in_scope.length-1].return_annotation) { expectedType = S.in_scope[S.in_scope.length-1].return_annotation.resolveType(S.in_scope); actualType = result.resolveType(S.in_scope); if (!(’ê’è_in(actualType, [ expectedType, "?" ]))) { croak("Type annotation states that function returns " + expectedType + ", actual returned type is " + actualType + ""); } } return result; } else if (tmp_ === "switch") { return new AST_Switch({ expression: parenthesised(), body: in_loop(switch_body_) }); } else if (tmp_ === "raise") { if (S.token.newline_before) { return new AST_Throw({ value: new AST_SymbolCatch({ name: "’ê’è_Exception" }) }); } tmp = expression(true); semicolon(); return new AST_Throw({ value: tmp }); } else if (tmp_ === "try") { return try_(); } else if (tmp_ === "nonlocal") { tmp = nonlocal_(); semicolon(); return tmp; } else if (tmp_ === "const") { tmp = const_(); semicolon(); return tmp; } else if (tmp_ === "with") { return new AST_With({ expression: parenthesised(), body: statement() }); } else { unexpected(); } } }, ’ê’è_2 = embed_tokens(’ê’è_2), ’ê’è_2); function labeled_statement() { var label, stat; label = as_symbol(AST_Label); if (find_if(function(l) { return l.name === label.name; }, S.labels)) { croak("Label " + label.name + " defined twice"); } expect(":"); S.labels.push(label); stat = statement(); S.labels.pop(); return new AST_LabeledStatement({ body: stat, label: label }); } function simple_statement(tmp) { var tmp; tmp = expression(true); semicolon(); return new AST_SimpleStatement({ body: tmp }); } function break_cont(type_) { var label; label = null; if (!can_insert_semicolon()) { label = as_symbol(AST_LabelRef, true); } if (label !== null) { if (!find_if(function(l) { return l.name === label.name; }, S.labels)) { croak("Undefined label " + label.name); } } else if (S.in_loop === 0) { croak(type.TYPE + " not inside a loop or switch"); } semicolon(); return new type_({ label: label }); } function seq_to_array(seq) { return new AST_Array({ start: seq.start, elements: seq.to_array(), end: seq.end }); } function for_(list_comp) { var init; init = null; if (!is_("punc", ";")) { init = expression(true, true); if (init instanceof AST_Seq) { init = seq_to_array(init); } if (is_("operator", "in")) { if (init instanceof AST_Var && init.definitions.length > 1) { croak("Only one variable declaration allowed in for..in loop"); } next(); return for_in(init, list_comp); } } unexpected(); } function for_in(init, list_comp) { var ’ê’èitr3, ’ê’èidx3, ’ê’èupk1; var lhs, obj, i, element, value; lhs = init instanceof AST_Var ? init.definitions[0].name : null; obj = expression(true); if (init instanceof AST_Array) { ’ê’èitr3 = ’ê’è_Iterable(enumerate(init.elements)); for (’ê’èidx3 = 0; ’ê’èidx3 < ’ê’èitr3.length; ’ê’èidx3++) { ’ê’èupk1 = ’ê’èitr3[’ê’èidx3]; i = ’ê’èupk1[0]; element = ’ê’èupk1[1]; value = null; if (obj instanceof AST_Call && obj.expression instanceof AST_SymbolRef && obj.expression.name === "enumerate") { if (i === 0) { value = "Number"; } } mark_local_assignment(element, value); } } else { value = null; if (obj instanceof AST_Call && obj.expression instanceof AST_SymbolRef && obj.expression.name === "range") { value = "Number"; } mark_local_assignment(init, value); } BASELIB["iterable"] = true; if (list_comp) { return { init: init, name: lhs, object: obj }; } return new AST_ForIn({ init: init, name: lhs, object: obj, body: in_loop(statement) }); } function for_js() { var condition; condition = expression(true, true); return new AST_ForJS({ condition: condition, body: in_loop(statement) }); } function get_class_in_scope(expr) { var ’ê’èitr4, ’ê’èidx4, ’ê’èitr5, ’ê’èidx5; var s, referenced_path, expr, class_name; if (expr instanceof AST_SymbolRef) { if (’ê’è_in(expr.name, NATIVE_CLASSES)) { return NATIVE_CLASSES[expr.name]; } ’ê’èitr4 = ’ê’è_Iterable(range(S.in_scope.length - 1, -1, -1)); for (’ê’èidx4 = 0; ’ê’èidx4 < ’ê’èitr4.length; ’ê’èidx4++) { s = ’ê’èitr4[’ê’èidx4]; if (’ê’è_in(expr.name, S.in_scope[s].classes)) { return S.in_scope[s].classes[expr.name]; } } } else if (expr instanceof AST_Dot) { referenced_path = []; while (expr instanceof AST_Dot) { referenced_path.unshift(expr.property); expr = expr.expression; } if (expr instanceof AST_SymbolRef) { referenced_path.unshift(expr.name); if (len(referenced_path) > 1) { class_name = referenced_path.join("."); ’ê’èitr5 = ’ê’è_Iterable(range(S.in_scope.length - 1, -1, -1)); for (’ê’èidx5 = 0; ’ê’èidx5 < ’ê’èitr5.length; ’ê’èidx5++) { s = ’ê’èitr5[’ê’èidx5]; if (’ê’è_in(class_name, S.in_scope[s].classes)) { return S.in_scope[s].classes[class_name]; } } } } } return false; } function do_import(key) { var ’ê’èitr7, ’ê’èidx7, ’ê’èupk3; var package_module_id, filename, src_code, modpath, location, data, contents; if (’ê’è_in(key, IMPORTED)) { return; } if (IMPORTING[key]) { throw ImportError("Detected a recursive import of: " + key + " while importing: " + module_id); } package_module_id = key.split(".").slice(0, -1).join("."); if (len(package_module_id) > 0) { do_import(package_module_id); } function safe_read(base_path) { var ’ê’èitr6, ’ê’èidx6, ’ê’èupk2; var i, path; ’ê’èitr6 = ’ê’è_Iterable(enumerate([ base_path + ".pyj", base_path + "/__init__.pyj" ])); for (’ê’èidx6 = 0; ’ê’èidx6 < ’ê’èitr6.length; ’ê’èidx6++) { ’ê’èupk2 = ’ê’èitr6[’ê’èidx6]; i = ’ê’èupk2[0]; path = ’ê’èupk2[1]; try { return [ options.readfile(path, "utf-8"), path ]; } catch (’ê’è_Exception) { var e = ’ê’è_Exception; if (e.code === "ENOENT" || e.code === "EPERM" || e.code === "EACCESS") { if (i === 1) { return [null, null]; } } if (i === 1) { throw ’ê’è_Exception; } } } } src_code = filename = null; modpath = key.replace(/\./g, "/"); ’ê’èitr7 = ’ê’è_Iterable(import_dirs); for (’ê’èidx7 = 0; ’ê’èidx7 < ’ê’èitr7.length; ’ê’èidx7++) { location = ’ê’èitr7[’ê’èidx7]; if (location) { ’ê’èupk3 = safe_read(location + "/" + modpath); data = ’ê’èupk3[0]; filename = ’ê’èupk3[1]; if (data !== null) { src_code = data; break; } } } if (src_code === null) { throw "Failed Import: '" + key + "' module doesn't exist in any of the import directories: " + import_dirs.join(", "); } contents = parse(src_code, { filename: filename, toplevel: null, readfile: options.readfile, basedir: options.basedir, libdir: options.libdir, module_id: key, IMPORTED: IMPORTED, IMPORTING: IMPORTING, auto_bind: options.auto_bind, es6: options.es6, import_dirs: options.import_dirs, dropDecorators: options.dropDecorators, dropImports: options.dropImports }); if (len(package_module_id) > 0) { IMPORTED[package_module_id].submodules.push(key); } } function import_(from_import) { var ’ê’èitr8, ’ê’èidx8, ’ê’èitr9, ’ê’èidx9; var ans, name, tmp, key, alias, imp, classes, argnames, aname, argvar, obj, i; ans = new AST_Imports({ "imports": [] }); while (true) { tmp = name = expression(false); key = ""; while (tmp instanceof AST_Dot) { key = "." + tmp.property + key; tmp = tmp.expression; } key = tmp.name + key; if (!keepDecoratorOrImport(key, true)) { return new AST_EmptyStatement({ start: prev(), end: prev() }); } alias = null; if (!from_import && is_("keyword", "as")) { next(); alias = as_symbol(AST_SymbolAlias); } imp = new AST_Import({ "module": name, "key": key, "alias": alias, "argnames": null, "body": function() { return IMPORTED[key]; } }); ans.imports.push(imp); if (from_import) { break; } if (is_("punc", ",")) { next(); } else { break; } } ’ê’èitr8 = ’ê’è_Iterable(ans["imports"]); for (’ê’èidx8 = 0; ’ê’èidx8 < ’ê’èitr8.length; ’ê’èidx8++) { imp = ’ê’èitr8[’ê’èidx8]; do_import(imp.key); classes = IMPORTED[key].classes; if (from_import) { expect_token("keyword", "import"); imp.argnames = argnames = []; while (true) { aname = as_symbol(AST_ImportedVar); if (is_("keyword", "as")) { next(); aname.alias = as_symbol(AST_SymbolAlias); } argnames.push(aname); if (is_("punc", ",")) { next(); } else { break; } } ’ê’èitr9 = ’ê’è_Iterable(argnames); for (’ê’èidx9 = 0; ’ê’èidx9 < ’ê’èitr9.length; ’ê’èidx9++) { argvar = ’ê’èitr9[’ê’èidx9]; obj = classes[argvar.name]; if (obj) { key = argvar.alias ? argvar.alias.name : argvar.name; S.in_scope[S.in_scope.length-1].classes[key] = { "static": obj.static, "bound": obj.bound }; } } } else { for (i in classes) { obj = classes[i]; if (obj instanceof AST_Class) { key = imp.alias ? imp.alias.name : imp.key; S.in_scope[S.in_scope.length-1].classes[key + "." + obj.name.name] = { "static": obj.static, "bound": obj.bound }; } } } } return ans; } function class_() { var ’ê’èitr12, ’ê’èidx12; var start, name, externaldecorator, class_details, parent, docstring, definition, i, stmt, class_var_names, visitor; start = prev(); name = as_symbol(AST_SymbolDefun); if (!name) { unexpected(); } externaldecorator = has_simple_decorator(S.decorators, "external"); class_details = { "static": [], "bound": {} }; parent = null; docstring = null; definition = new AST_Class({ start: start, name: name, module_id: module_id, parent: function() { var atom; if (is_("punc", "(")) { next(); if (is_("punc", ")")) { S.in_parenthesized_expr = false; next(); return null; } atom = expr_atom(false); expect(")"); parent = atom.name; return atom; } else { return null; } }(), localvars: [], static: class_details.static, external: externaldecorator, bound: class_details.bound, statements: [], decorators: function() { var ’ê’èitr10, ’ê’èidx10; var d, decorator; d = []; ’ê’èitr10 = ’ê’è_Iterable(S.decorators); for (’ê’èidx10 = 0; ’ê’èidx10 < ’ê’èitr10.length; ’ê’èidx10++) { decorator = ’ê’èitr10[’ê’èidx10]; if (decorator === "kwargs") { BASELIB["kwargs"] = true; } d.push(new AST_Decorator({ expression: decorator })); } S.decorators = []; return d; }(), body: function(loop, labels) { var a; S.in_scope[S.in_scope.length-1].classes[name.name] = class_details; S.in_scope.push({ type: "class", name: name.name, parent: parent, nonlocal: {}, functions: {}, vars: {}, classes: {} }); S.in_directives = true; S.in_loop = 0; S.labels = []; a = block_(); docstring = S.in_scope[S.in_scope.length-1].docstring; S.in_scope.pop(); S.in_loop = loop; S.labels = labels; return a; }(S.in_loop, S.labels), docstring: docstring, end: prev() }); for (i in definition.body) { stmt = definition.body[i]; if (stmt instanceof AST_Method && stmt.name.name === "__init__") { definition.init = stmt; break; } } class_var_names = {}; function walker() { this._visit = function(node, descend) { var ’ê’èitr11, ’ê’èidx11; var child; if (node instanceof AST_Method) { class_var_names[node.name.name] = true; return; } else if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) { class_var_names[node.left.name] = true; } ’ê’èitr11 = ’ê’è_Iterable(node); for (’ê’èidx11 = 0; ’ê’èidx11 < ’ê’èitr11.length; ’ê’èidx11++) { child = ’ê’èitr11[’ê’èidx11]; if (node[child] instanceof AST_SymbolRef && Object.prototype.hasOwnProperty.call(class_var_names, node[child].name)) { node[child] = new AST_SymbolClassRef({ "class": name, "name": node[child].name }); } } if (descend) { descend.call(node); } }; } visitor = new walker(); ’ê’èitr12 = ’ê’è_Iterable(definition.body); for (’ê’èidx12 = 0; ’ê’èidx12 < ’ê’èitr12.length; ’ê’èidx12++) { stmt = ’ê’èitr12[’ê’èidx12]; if (!(stmt instanceof AST_Class) && !(stmt instanceof AST_Method)) { stmt.walk(visitor); definition.statements.push(stmt); } } if (S.in_scope.length === 1) { CLASS_MAP[definition.name.name] = definition; } return definition; } function function_(in_class, ctor) { var start, is_accessor, name, generator, localvars, staticmethod, function_args, return_annotation, has_special_decorator, ctor, docstring, definition; start = prev(); is_accessor = ctor === AST_ObjectGetter || ctor === AST_ObjectSetter; name = is_("name") ? as_symbol(in_class ? AST_SymbolDefun : is_accessor ? AST_SymbolAccessor : AST_SymbolLambda) : is_accessor && (is_("string") || is_("num")) ? as_atom_node() : null; if (in_class && !name) { unexpected(); } generator = false; localvars = null; staticmethod = false; function_args = {}; return_annotation = null; if (!S.in_decorator) { has_special_decorator = function(name) { return has_simple_decorator(S.decorators, name); }; if (in_class) { if (has_special_decorator("staticmethod")) { S.in_scope[S.in_scope.length-2].classes[in_class].static.push(name.name); staticmethod = true; } if (has_special_decorator("bind") || name.name !== "__init__" && options.auto_bind) { BASELIB["bind"] = true; S.in_scope[S.in_scope.length-2].classes[in_class].bound[name.name] = true; } } } expect("("); if (!ctor) { ctor = in_class ? AST_Method : AST_Function; } docstring = null; definition = new ctor({ start: start, name: name, argnames: function(a) { var defaults, first, seen_names, def_line, val, expr; defaults = {}; first = true; seen_names = {}; def_line = S.input.context().tokline; function get_arg() { var name_token, name_ctx, ntok, annotation, sym; if (Object.prototype.hasOwnProperty.call(seen_names, S.token.value)) { token_error(prev(), "Can't repeat parameter names"); } if (S.token.value === "arguments") { token_error(prev(), "Can't use the name arguments as a parameter name, it is reserved by JavaScript"); } seen_names[S.token.value] = true; name_token = S.token; name_ctx = S.input.context(); ntok = peek(); if (ntok.type === "punc" && ntok.value === ":") { next(); expect(":"); annotation = maybe_conditional(); if (!is_token(name_token, "name")) { croak("Name expected", name_ctx.tokline); return null; } sym = new AST_SymbolFunarg({ "name": name_token.value, "start": S.token, "end": S.token, "annotation": annotation ? new AST_Annotation({ "start": annotation.start, "expression": annotation, "end": annotation.end }) : null }); } else { if (!is_("name")) { if (S.input.context().tokline !== def_line) { croak("Name expected", def_line); } else { croak("Name expected"); } return null; } sym = new AST_SymbolFunarg({ "name": S.token.value, "start": S.token, "end": S.token, "annotation": null }); next(); } function_args[sym.name] = sym.annotation ? sym.annotation.resolveType(S.in_scope) : "?"; return sym; } while (!is_("punc", ")")) { if (first) { first = false; } else { expect(","); } if (is_("operator", "**")) { token_error(prev(), "**kwargs in function definition is not implemented yet, work in progress"); next(); if (a.kwargs) { token_error(prev(), "Can't define multiple **kwargs in function definition"); } a.kwargs = get_arg(); } else if (is_("operator", "*")) { next(); if (a.starargs) { token_error(prev(), "Can't define multiple *args in function definition"); } if (a.kwargs) { token_error(prev(), "Can't define *args after **kwargs in function definition"); } a.starargs = get_arg(); } else { if (a.starargs || a.kwargs) { token_error(prev(), "Can't define a formal parameter after *args or **kwargs"); } a.push(get_arg()); if (is_("operator", "=")) { if (a.kwargs) { token_error(prev(), "Can't define an optional formal parameter after **kwargs"); } val = prev().value; next(); defaults[val] = expression(false); a.has_defaults = true; } else { if (a.has_defaults) { token_error(prev(), "Can't define required formal parameters after optional formal parameters"); } } } } next(); if (is_("punc", "->")) { next(); expr = expression(true); return_annotation = new AST_Annotation({ start: expr.start, expression: expr, end: expr.end }); } a.defaults = defaults; return a; }([]), decorators: S.in_decorator ? [] : function() { var ’ê’èitr13, ’ê’èidx13; var d, decorator; d = []; ’ê’èitr13 = ’ê’è_Iterable(S.decorators); for (’ê’èidx13 = 0; ’ê’èidx13 < ’ê’èitr13.length; ’ê’èidx13++) { decorator = ’ê’èitr13[’ê’èidx13]; d.push(new AST_Decorator({ expression: decorator })); } S.decorators = []; return d; }(), return_annotation: return_annotation, body: function(loop, labels) { var a, variable; S.in_scope.push({ type: "function", name: name ? name.name : null, return_annotation: return_annotation, nonlocal: {}, vars: {}, args: function_args, functions: {}, classes: {} }); S.in_directives = true; S.in_loop = 0; S.labels = []; a = block_(); generator = S.in_scope[S.in_scope.length-1].generator; docstring = S.in_scope[S.in_scope.length-1].docstring; if (generator) { ’ê’è_print(S.in_scope[S.in_scope.length-1]); } localvars = (function() { var ’ê’èidx14, ’ê’èitr14 = ’ê’è_Iterable(Object.keys(S.in_scope[S.in_scope.length-1].vars)), ’ê’ères = [], variable; for (’ê’èidx14 = 0; ’ê’èidx14 < ’ê’èitr14.length; ’ê’èidx14++) { variable = ’ê’èitr14[’ê’èidx14]; if (!(’ê’è_in(variable, S.in_scope[S.in_scope.length-1].nonlocal))) { ’ê’ères.push(new_symbol(AST_SymbolVar, variable)); } } return ’ê’ères; })(); S.in_scope.pop(); S.in_loop = loop; S.labels = labels; return a; }(S.in_loop, S.labels), docstring: docstring, generator: generator, localvars: localvars, end: prev(), static: in_class && staticmethod }); if (name) { S.in_scope[S.in_scope.length-1].functions[name.name] = definition.resolveType(S.in_scope); } if (in_class && !staticmethod) { if (definition.argnames.length < 1) { croak("Class methods require at least one argument (self)", start.line, start.col, start.pos); } else if (ctor === AST_ObjectGetter && definition.argnames.length !== 1) { croak("Class getters don't take any arguments aside from one referencing the instance (self)", start.line, start.col, start.pos); } else if (ctor === AST_ObjectSetter && definition.argnames.length !== 2) { croak("Class setters take exactly 2 arguments (self, value)", start.line, start.col, start.pos); } } else if (is_accessor) { if (ctor === AST_ObjectGetter && definition.argnames.length) { croak("Object getters don't take any arguments", start.line, start.col, start.pos); } else if (ctor === AST_ObjectSetter && definition.argnames.length !== 1) { croak("Object setters take exactly 1 argument", start.line, start.col, start.pos); } } return definition; } function accessor_(type, start, in_class) { var func; if (type === "get") { func = function_(in_class, AST_ObjectGetter); } else if (type === "set") { func = function_(in_class, AST_ObjectSetter); } else { croak("Expecting setter/getter, got '" + type + "' instead."); } func.start = start; func.end = prev(); return func; } function if_() { var cond, body, belse; cond = expression(true); body = statement(); belse = null; if (is_("keyword", "elif") || is_("keyword", "else")) { if (is_("keyword", "else")) { next(); } else { S.token.value = "if"; } belse = statement(); } return new AST_If({ condition: cond, body: body, alternative: belse }); } function is_docstring(stmt) { if (stmt instanceof AST_Directive && !S.in_scope[S.in_scope.length-1].docstring) { return true; } return false; } function format_docstring(string) { var ’ê’èitr15, ’ê’èidx15, ’ê’èitr16, ’ê’èidx16; var lines, indent, line, pad, trimmed; lines = string.split(/\n/g); indent = 1e6; ’ê’èitr15 = ’ê’è_Iterable(lines.slice(1)); for (’ê’èidx15 = 0; ’ê’èidx15 < ’ê’èitr15.length; ’ê’èidx15++) { line = ’ê’èitr15[’ê’èidx15]; if (line.trim().length) { pad = line.match(/^\s*/)[0]; indent = Math.min(indent, pad.length); } } trimmed = [ lines[0].trim() ]; if (indent < 1e6) { ’ê’èitr16 = ’ê’è_Iterable(lines.slice(1)); for (’ê’èidx16 = 0; ’ê’èidx16 < ’ê’èitr16.length; ’ê’èidx16++) { line = ’ê’èitr16[’ê’èidx16]; trimmed.push(line.slice(indent).replace(/\s+$/)); } } while (trimmed && !trimmed[trimmed.length-1]) { trimmed.pop(); } while (trimmed && !trimmed[0]) { trimmed.shift(); } return trimmed.join("\n"); } function block_() { var a, stmt; expect(":"); a = []; if (!S.token.newline_before) { while (!S.token.newline_before) { if (is_("eof")) { unexpected(); } stmt = statement(); if (!a.length && is_docstring(stmt)) { S.in_scope[S.in_scope.length-1].docstring = format_docstring(stmt.value); } else { a.push(stmt); } } } else { while (!is_("punc", "}")) { if (is_("eof")) { return a; } stmt = statement(); if (!a.length && is_docstring(stmt)) { S.in_scope[S.in_scope.length-1].docstring = format_docstring(stmt.value); } else { a.push(stmt); } } next(); } return a; } function switch_body_() { var a, cur, branch; expect("{"); a = []; cur = null; branch = null; while (!is_("punc", "}")) { if (is_("eof")) { unexpected(); } if (is_("keyword", "case")) { if (branch) { branch.end = prev(); } cur = []; branch = new AST_Case({ start: function() { var tmp; tmp = S.token; next(); return tmp; }(), expression: expression(true), body: cur }); a.push(branch); expect(":"); } else if (is_("keyword", "default")) { if (branch) { branch.end = prev(); } cur = []; branch = new AST_Default({ start: function() { var tmp; tmp = S.token; next(); expect(":"); return tmp; }(), body: cur }); a.push(branch); } else { if (!cur) { unexpected(); } cur.push(statement()); } } if (branch) { branch.end = prev(); } next(); return a; } function try_() { var body, bcatch, bfinally, start, exceptions, name; body = block_(); bcatch = []; bfinally = null; while (is_("keyword", "except")) { start = S.token; next(); exceptions = []; if (!is_("punc", ":") && !is_("keyword", "as")) { exceptions.push(as_symbol(AST_SymbolVar)); while (is_("punc", ",")) { next(); exceptions.push(as_symbol(AST_SymbolVar)); } } name = null; if (is_("keyword", "as")) { next(); name = as_symbol(AST_SymbolCatch); } bcatch.push(new AST_Except({ start: start, argname: name, errors: exceptions, body: block_(), end: prev() })); } if (is_("keyword", "finally")) { start = S.token; next(); bfinally = new AST_Finally({ start: start, body: block_(), end: prev() }); } if (!bcatch.length && !bfinally) { croak("Missing except/finally blocks"); } return new AST_Try({ body: body, bcatch: bcatch.length ? new AST_Catch({ body: bcatch }) : null, bfinally: bfinally }); } function vardefs(no_in, type) { var a, symbol; a = []; while (true) { symbol = new AST_VarDef({ start: S.token, name: as_symbol(type === "const" ? AST_SymbolConst : type === "nonlocal" ? AST_SymbolNonlocal : AST_SymbolVar), end: prev() }); if (type === "nonlocal") { S.in_scope[S.in_scope.length-1].nonlocal[symbol.name.name] = true; } a.push(symbol); if (!is_("punc", ",")) { break; } next(); } return a; } function nonlocal_(no_in) { return new AST_Var({ start: prev(), definitions: vardefs(no_in, "nonlocal"), end: prev() }); } function const_() { return new AST_Const({ start: prev(), definitions: vardefs(false, "const"), end: prev() }); } function new_() { var start, newexp, args; start = S.token; expect_token("operator", "new"); newexp = expr_atom(false); if (is_("punc", "(")) { next(); args = expr_list(")"); } else { args = []; } return subscripts(new AST_New({ start: start, expression: newexp, args: args, end: prev() }), true); } function as_atom_node(token) { var tok, tmp_, token, ret, tmp__; tok = token || S.token; tmp_ = tok.type; if (tmp_ === "name") { if (tok.value === "NaN") { ret = kwargs(as_symbol)(AST_NaN, {token: tok}); } else if (tok.value === "undefined") { ret = kwargs(as_symbol)(AST_Undefined, {token: tok}); } else { ret = kwargs(as_symbol)(AST_SymbolRef, {token: tok}); } } else if (tmp_ === "num") { ret = new AST_Number({ start: tok, end: tok, value: tok.value }); } else if (tmp_ === "string") { ret = new AST_String({ start: tok, end: tok, value: tok.value, modifier: tok.subtype }); } else if (tmp_ === "regexp") { ret = new AST_RegExp({ start: tok, end: tok, value: tok.value }); } else if (tmp_ === "atom") { tmp__ = tok.value; if (tmp__ === "False") { ret = new AST_False({ start: tok, end: tok }); } else if (tmp__ === "True") { ret = new AST_True({ start: tok, end: tok }); } else if (tmp__ === "None") { ret = new AST_Null({ start: tok, end: tok }); } } if (!token) { next(); } ret.resolveType(S.in_scope); return ret; } function expr_atom(allow_calls) { var start, tmp_, ex, cls, func; if (is_("operator", "new")) { return new_(); } start = S.token; if (is_("punc")) { tmp_ = start.value; if (tmp_ === "(") { next(); ex = expression(true); ex.start = start; ex.end = S.token; if (ex instanceof AST_SymbolRef) { ex.parens = true; } expect(")"); return subscripts(ex, allow_calls); } else if (tmp_ === "[") { return subscripts(array_(), allow_calls); } else if (tmp_ === "{") { return subscripts(object_(), allow_calls); } unexpected(); } if (is_("keyword", "class")) { next(); cls = class_(); cls.start = start; cls.end = prev(); return subscripts(cls, allow_calls); } if (is_("keyword", "def")) { next(); func = function_(false); func.start = start; func.end = prev(); return subscripts(func, allow_calls); } if (ATOMIC_START_TOKEN[S.token.type]) { return subscripts(as_atom_node(), allow_calls); } unexpected(); } function expr_list(closing, allow_trailing_comma, allow_empty, func_call) { var ’ê’èitr17, ’ê’èidx17, ’ê’èupk4; var first, a, saw_starargs, tmp, i, arg; first = true; a = []; saw_starargs = false; while (!is_("punc", closing)) { if (saw_starargs) { token_error(prev(), "*args must be the last argument in a function call"); } if (first) { first = false; } else { expect(","); } if (allow_trailing_comma && is_("punc", closing)) { break; } if (is_("operator", "*") && func_call) { saw_starargs = true; next(); } if (is_("punc", ",") && allow_empty) { a.push(new AST_Hole({ start: S.token, end: S.token })); } else { a.push(expression(false)); } } if (func_call) { tmp = []; tmp.kwargs = []; ’ê’èitr17 = ’ê’è_Iterable(enumerate(a)); for (’ê’èidx17 = 0; ’ê’èidx17 < ’ê’èitr17.length; ’ê’èidx17++) { ’ê’èupk4 = ’ê’èitr17[’ê’èidx17]; i = ’ê’èupk4[0]; arg = ’ê’èupk4[1]; if (arg instanceof AST_Assign) { BASELIB["kwargs"] = true; tmp.kwargs.push([ arg.left, arg.right ]); } else { tmp.push(arg); } } a = tmp; } next(); if (saw_starargs) { a.starargs = true; } return a; } function func_call_list() { var a, first, kwargs, arg; a = []; first = true; a.kwargs = []; a.kwarg_items = kwargs = []; a.starargs = false; while (!is_("punc", ")")) { if (first) { first = false; } else { expect(","); } if (is_("operator", "*")) { next(); arg = expression(false); arg.is_array = true; a.push(arg); a.starargs = true; } else if (is_("operator", "**")) { BASELIB["kwargs"] = true; next(); kwargs.push(as_symbol(AST_SymbolVar, false)); } else { arg = expression(false); if (arg instanceof AST_Assign) { BASELIB["kwargs"] = true; a.kwargs.push([ arg.left, arg.right ]); } else { a.push(arg); } } } next(); return a; } function read_comprehension(object) { var terminator, forloop; terminator = object instanceof AST_DictComprehension ? "}" : "]"; expect_token("keyword", "for"); forloop = for_(true); BASELIB["iterable"] = true; object.init = forloop.init; object.name = forloop.name; object.object = forloop.object; object.condition = is_("punc", terminator) ? null : (expect_token("keyword", "if"), expression(true)); expect(terminator); return object; } var array_ = (’ê’è_3 = function array_() { var expr, ret; expect("["); expr = []; if (!is_("punc", "]")) { expr.push(expression(false)); if (is_("keyword", "for")) { return read_comprehension(new AST_ListComprehension({ statement: expr[0] })); } if (is_("operator", "til")) { BASELIB["range"] = true; next(); expr.push(expression(false)); ret = new AST_Range({ start: S.token, left: expr[0], operator: "til", right: expr[1], end: prev() }); expect("]"); return ret; } else if (is_("operator", "to")) { BASELIB["range"] = true; next(); expr.push(expression(false)); ret = new AST_Range({ start: S.token, left: expr[0], operator: "to", right: expr[1], end: prev() }); expect("]"); return ret; } else if (!is_("punc", "]")) { expect(","); } } return new AST_Array({ elements: expr.concat(expr_list("]", !options.strict, true)) }); }, ’ê’è_3 = embed_tokens(’ê’è_3), ’ê’è_3); var object_ = (’ê’è_4 = function object_() { var maybe_dict_comprehension, first, a, start, type, computed, saw_starargs, key, name, ctx, orig, key_; maybe_dict_comprehension = false; expect("{"); first = true; a = []; while (!is_("punc", "}")) { if (!first) { expect(","); } if (!options.strict && is_("punc", "}")) { break; } start = S.token; type = start.type; computed = false; saw_starargs = false; if (is_("operator", "*")) { saw_starargs = true; if (!options.es6) { croak("Spread operator in object literals is only allowed in ES6 mode"); } a.push(maybe_unary(true)); } else if (first && peek().value !== ":") { maybe_dict_comprehension = true; key = expression(false); name = null; } else { ctx = S.input.context(); orig = ctx.expect_object_literal_key; ctx.expect_object_literal_key = true; if (is_("punc", "(")) { if (!options.es6) { croak("Computed properties are only allowed in ES6 mode"); } expect("("); key = expression(false); expect(")"); computed = true; } else { key_ = as_property_name(); name = key_.value; if (key_.type === "num") { key = new AST_Number({ start: start, value: name, end: prev() }); } else if (key_.type === "name" || key_.type === "keyword") { if (’ê’è_in(name, [ "True", "False" ])) { key = new AST_Boolean({ start: start, value: name, end: prev() }); } else { key = new AST_Identifier({ start: start, value: name, end: prev() }); } } else { key = new AST_String({ start: start, value: name, end: prev() }); } } ctx.expect_object_literal_key = orig; if (type === "name" && !is_("punc", ":")) { a.push(accessor_(name, start, false)); continue; } } if (!saw_starargs) { expect(":"); a.push(new AST_ObjectKeyVal({ start: start, key: key, value: expression(false), end: prev() })); if (a.length === 1 && is_("keyword", "for")) { return read_comprehension(new AST_DictComprehension({ statement: maybe_dict_comprehension ? key : as_atom_node(a[0].start), value_statement: a[0].value })); } } first = false; } next(); return new AST_Object({ properties: a }); }, ’ê’è_4 = embed_tokens(’ê’è_4), ’ê’è_4); function as_property_name() { var tmp, tmp_; tmp = S.token; next(); tmp_ = tmp.type; if (tmp_ === "num" || tmp_ === "string" || tmp_ === "name" || tmp_ === "operator" || tmp_ === "keyword" || tmp_ === "atom") { return tmp; } else { unexpected(); } } function as_name() { var tmp, tmp_; tmp = S.token; next(); tmp_ = tmp.type; if (tmp_ === "name" || tmp_ === "operator" || tmp_ === "keyword" || tmp_ === "atom") { return tmp.value; } else { unexpected(); } } function as_symbol(type, noerror, token) { var token_, name, sym; token_ = token || S.token; if (!is_token(token_, "name")) { if (!noerror) { croak("Name expected"); } return null; } name = token_.value; sym = new (name === "this" ? AST_This : type)({ name: String(token_.value), start: token_, end: token_ }); if (!token) { next(); } return sym; } function new_symbol(type, name) { var sym; sym = new (name === "this" ? AST_This : type)({ name: String(name), start: null, end: null }); return sym; } function is_static_method(cls, method) { if (’ê’è_in(method, COMMON_STATIC) || cls.static && ’ê’è_in(method, cls.static)) { return true; } else { return false; } } function mark_local_assignment(element, value) { var computedType, name; if (value) { computedType = typeof value === "string" ? value : value.resolveType(S.in_scope); } else { computedType = "?"; } name = typeof element === "string" ? element : element.name; if (name) { if (’ê’è_in(name, S.in_scope[S.in_scope.length-1].vars)) { S.in_scope[S.in_scope.length-1].vars[name].push(computedType); } else { S.in_scope[S.in_scope.length-1].vars[name] = [ computedType ]; } } } function subscripts(expr, allow_calls) { var start, slice_bounds, is_slice, i, str_, ret, cls, funcname, tmp_, args; start = expr.start; if (is_("punc", ".")) { next(); return subscripts(new AST_Dot({ start: start, expression: expr, property: as_name(), end: prev() }), allow_calls); } if (is_("punc", "[") && !S.token.newline_before) { next(); slice_bounds = []; is_slice = false; if (is_("punc", ":")) { slice_bounds.push(null); } else { slice_bounds.push(expression(false)); } if (is_("punc", ":")) { is_slice = true; next(); if (is_("punc", ":")) { slice_bounds.push(null); } else if (!is_("punc", "]")) { slice_bounds.push(expression(false)); } } if (is_("punc", ":")) { BASELIB["eslice"] = true; next(); if (is_("punc", "]")) { unexpected(); } else { slice_bounds.push(expression(false)); } } expect("]"); if (is_slice) { if (is_("operator") && S.token.value === "=") { next(); return subscripts(new AST_Slice({ start: start, expression: expr, property: slice_bounds[0] || new AST_Number({ value: 0 }), property2: slice_bounds[1], assignment: expression(true), end: prev() }), allow_calls); } else if (slice_bounds.length === 3) { slice_bounds.unshift(slice_bounds.pop()); if (!slice_bounds[slice_bounds.length-1]) { slice_bounds.pop(); if (!slice_bounds[slice_bounds.length-1]) { slice_bounds.pop(); } } else if (!slice_bounds[slice_bounds.length-2]) { slice_bounds[slice_bounds.length-2] = new AST_Undefined(); } return subscripts(new AST_Call({ start: start, expression: new AST_SymbolRef({ name: "eslice" }), args: [ expr ].concat(slice_bounds), end: prev() }), allow_calls); } else { slice_bounds = (function() { var ’ê’èidx18, ’ê’èitr18 = ’ê’è_Iterable(slice_bounds), ’ê’ères = [], i; for (’ê’èidx18 = 0; ’ê’èidx18 < ’ê’èitr18.length; ’ê’èidx18++) { i = ’ê’èitr18[’ê’èidx18]; ’ê’ères.push(i === null ? new AST_Number({ value: 0 }) : i); } return ’ê’ères; })(); return subscripts(new AST_Call({ start: start, expression: new AST_Dot({ start: start, expression: expr, property: "slice", end: prev() }), args: slice_bounds, end: prev() }), allow_calls); } } else { return subscripts(new AST_Sub({ start: start, expression: expr, property: slice_bounds[0] || new AST_Number({ value: 0 }), end: prev() }), allow_calls); } } if (allow_calls && is_("punc", "(") && !S.token.newline_before) { next(); if (expr instanceof AST_SymbolRef && expr.name === "JS") { str_ = expression(false); if (!(str_ instanceof AST_String)) { token_error(prev(), "Compile-time function JS() can't evaluate variables or expressions"); } ret = new AST_Verbatim({ start: start, value: str_.value, end: prev() }); expect(")"); return subscripts(ret, true); } else if (!expr.parens && get_class_in_scope(expr)) { if (’ê’è_in(expr.name, STDLIB)) { BASELIB[expr.name] = true; if (/Error$/.test(expr.name)) { BASELIB["extends"] = true; } } return subscripts(new AST_New({ start: start, expression: expr, args: func_call_list(), end: prev() }), true); } else { if (expr instanceof AST_Dot) { cls = get_class_in_scope(expr.expression); } if (cls) { funcname = expr; if (funcname.property === "__init__") { funcname.property = "constructor"; } return validateCallArgs(subscripts(new AST_ClassCall({ start: start, class: expr.expression, method: funcname.property, super: S.in_scope.length > 1 && S.in_scope[S.in_scope.length-2].type === "class" && expr.expression.name === S.in_scope[S.in_scope.length-2].parent, static: is_static_method(cls, funcname.property), args: func_call_list(), end: prev() }), true)); } else if (expr instanceof AST_SymbolRef) { tmp_ = expr.name; if (’ê’è_in(tmp_, STDLIB)) { BASELIB[tmp_] = true; } else if (tmp_ === "isinstance") { args = func_call_list(); return new AST_Binary({ start: start, operator: "instanceof", left: args[0], right: args[1], end: prev() }); } } return validateCallArgs(subscripts(new AST_Call({ start: start, expression: expr, args: func_call_list(), end: prev() }), true)); } } return expr; } function keepDecoratorOrImport(expr, imp) { imp = imp === void 0 ? false : imp; var name; if (imp) { if (!options.dropImports.length) { return true; } } else { if (!options.dropDecorators.length) { return true; } } function stringifyName(expr) { if (expr instanceof AST_Dot) { return stringifyName(expr.expression) + "." + expr.property; } return expr.name; } if (typeof expr === "string") { name = expr; } else if (expr instanceof AST_SymbolRef) { name = expr.name; } else if (expr instanceof AST_Dot) { name = stringifyName(expr); } else if (expr instanceof AST_Call) { name = stringifyName(expr.expression); } else { croak("Unsupported decorator"); } if (imp) { return !(’ê’è_in(name, options.dropImports)); } else { return !(’ê’è_in(name, options.dropDecorators)); } } function maybe_unary(allow_calls) { var start, expr, ex, val; start = S.token; if (is_("operator", "@")) { if (S.in_decorator) { croak("Nested decorators are not allowed"); } next(); S.in_decorator = true; expr = expression(true); S.in_decorator = false; if (keepDecoratorOrImport(expr)) { S.decorators.push(expr); } return new AST_EmptyStatement({ stype: "@", start: prev(), end: prev() }); } if (is_("operator") && UNARY_PREFIX(start.value)) { next(); ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls)); ex.start = start; ex.end = prev(); return ex; } val = expr_atom(allow_calls); while (is_("operator") && UNARY_POSTFIX(S.token.value) && !S.token.newline_before) { val = make_unary(AST_UnaryPostfix, S.token.value, val); val.start = start; val.end = S.token; next(); } return val; } function make_unary(ctor, op, expr) { return validateUnary(new ctor({ operator: op, expression: expr })); } function validateBinary(astElement) { var left, right, op; left = astElement.left.resolveType(S.in_scope); right = astElement.right.resolveType(S.in_scope); op = astElement.operator; if (!(’ê’è_in(op, [ "in", "instanceof", "==", "!=", "===", "!==", "||", "&&", "=" ])) && (!(’ê’è_in(left, [ "Number", "String", "Boolean", "?" ])) || !(’ê’è_in(right, [ "Number", "String", "Boolean", "?" ])) || left === "String" && !(’ê’è_in(op, [ "+", "+=" ])) || right === "String" && !(’ê’è_in(op, [ "+", "+=" ])))) { if (left[0] === "[") { left = "Array"; } else if (left[0] === "{") { left = "Object"; } if (right[0] === "[") { right = "Array"; } else if (right[0] === "{") { right = "Object"; } throw croak("cannot perform binary '" + op + "' operation on incompatbile elements of type " + left + " and " + right + ""); } return astElement; } function validateUnary(astElement) { var element, op; element = astElement.expression.resolveType(S.in_scope); op = astElement.operator; if (!(’ê’è_in(element, [ "Number", "?" ])) && ’ê’è_in(op, [ "+", "-" ]) || !(’ê’è_in(element[0], [ "[", "{", "?" ])) && op === "*") { if (element[0] === "[") { element = "Array"; } else if (element[0] === "{") { element = "Object"; } throw croak("cannot perform unary '" + op + "' operation on incompatbile element of type " + element); } return astElement; } function validateCallArgs(astElement) { var ’ê’èitr19, ’ê’èidx19, ’ê’èitr20, ’ê’èidx20, ’ê’èitr21, ’ê’èidx21, ’ê’èitr22, ’ê’èidx22, ’ê’èupk5; var name, found, scope, func, signature, variable, args, i, arg, expected, actual; if (astElement.expression instanceof AST_SymbolRef) { name = astElement.expression.name; found = false; ’ê’èitr19 = ’ê’è_Iterable(reversed(S.in_scope)); for (’ê’èidx19 = 0; ’ê’èidx19 < ’ê’èitr19.length; ’ê’èidx19++) { scope = ’ê’èitr19[’ê’èidx19]; ’ê’èitr20 = ’ê’è_Iterable(scope.functions); for (’ê’èidx20 = 0; ’ê’èidx20 < ’ê’èitr20.length; ’ê’èidx20++) { func = ’ê’èitr20[’ê’èidx20]; if (func === name) { signature = scope.functions[func]; found = true; break; } } ’ê’èitr21 = ’ê’è_Iterable(scope.vars); for (’ê’èidx21 = 0; ’ê’èidx21 < ’ê’èitr21.length; ’ê’èidx21++) { variable = ’ê’èitr21[’ê’èidx21]; if (variable === name) { signature = scope.vars[func]; found = true; break; } } if (found) { break; } } if (signature && signature.slice(0, 9) === "Function(") { args = /\((.*)\)/.exec(signature)[1].split(","); if (args.length === 1 && !args[0].length) { args.pop(); } if (args.length < astElement.args.length) { croak("Function '" + name + "' takes " + args.length + " arguments, yet your call contains " + astElement.args.length + ""); } ’ê’èitr22 = ’ê’è_Iterable(enumerate(astElement.args)); for (’ê’èidx22 = 0; ’ê’èidx22 < ’ê’èitr22.length; ’ê’èidx22++) { ’ê’èupk5 = ’ê’èitr22[’ê’èidx22]; i = ’ê’èupk5[0]; arg = ’ê’èupk5[1]; expected = args[i].trim(); actual = arg.resolveType(S.in_scope); if (expected !== "?" && !(’ê’è_in(actual, [ expected, "?" ]))) { croak("Function '" + name + "' expects argument " + i + " type of " + expected + ", but you're passing " + actual + ""); } } } } return astElement; } function expr_op(left, min_prec, no_in) { var op, not_in, prec, right, ret; op = is_("operator") ? S.token.value : null; not_in = false; if (op === "!" && peek().type === "operator" && peek().value === "in") { next(); op = "in"; not_in = true; } if (op === "in") { if (no_in) { op = null; } else { BASELIB[op] = true; } } prec = op !== null ? PRECEDENCE[op] : null; if (prec !== null && prec > min_prec) { next(); right = expr_op(maybe_unary(true), prec, no_in); if (’ê’è_in(op, [ "==", "!=" ])) { BASELIB["eq"] = true; ret = new AST_DeepEquality({ start: left.start, left: left, operator: op, right: right, end: right.end }); } else { ret = new AST_Binary({ start: left.start, left: left, operator: op, right: right, end: right.end }); validateBinary(ret); } if (not_in) { ret = new AST_UnaryPrefix({ start: left.start, operator: "!", expression: ret, end: right.end }); } return expr_op(ret, min_prec, no_in); } return left; } function expr_ops(no_in) { return expr_op(maybe_unary(true), 0, no_in); } function maybe_conditional(no_in) { var start, expr, yes; start = S.token; expr = expr_ops(no_in); if (is_("operator", "?")) { next(); yes = expression(false); expect(":"); return new AST_Conditional({ start: start, condition: expr, consequent: yes, alternative: expression(false, no_in), end: peek() }); } return expr; } function isAssignable(expr) { var ’ê’èitr23, ’ê’èidx23; var element; if (expr instanceof AST_SymbolRef || expr instanceof AST_PropAccess) { return true; } if (expr instanceof AST_Array) { ’ê’èitr23 = ’ê’è_Iterable(expr.elements); for (’ê’èidx23 = 0; ’ê’èidx23 < ’ê’èitr23.length; ’ê’èidx23++) { element = ’ê’èitr23[’ê’èidx23]; if (!isAssignable(element)) { return false; } } return true; } if (expr instanceof AST_Seq) { if (isAssignable(expr.car) && isAssignable(expr.cdr)) { return true; } } return false; } function maybe_assign(no_in) { var start, left, val, right; start = S.token; left = maybe_conditional(no_in); val = S.token.value; if (is_("operator") && ASSIGNMENT(val)) { if (isAssignable(left)) { if (left instanceof AST_SymbolRef && val !== "=" && !(’ê’è_in(left.name, S.in_scope[S.in_scope.length-1].vars)) && (!S.in_scope[S.in_scope.length-1].args || !(’ê’è_in(left.name, S.in_scope[S.in_scope.length-1].args))) && !(’ê’è_in(left.name, S.in_scope[S.in_scope.length-1].nonlocal))) { croak("Attempting to increment/modify uninitialized variable '" + left.name + "', this can also occur if you're trying to shadow without initializing the variable in local scope."); } next(); right = maybe_assign(no_in); if (!S.in_seq) { mark_local_assignment(left, right); } return validateBinary(new AST_Assign({ start: start, left: left, operator: val, right: right, end: prev() })); } croak("Invalid assignment"); } return left; } function expression(commas, no_in) { var ’ê’èitr24, ’ê’èidx24, ’ê’èupk6, ’ê’èitr25, ’ê’èidx25, ’ê’èupk7; var start, expr, left, leftAst, right, index, element, seq; start = S.token; expr = maybe_assign(no_in); if (commas) { left = [ expr ]; while (is_("punc", ",") && !peek().newline_before) { S.in_seq = true; next(); if (expr instanceof AST_Assign) { left[left.length-1] = left[left.length-1].left; if (left.length === 1) { if (left[0] instanceof AST_Seq) { leftAst = seq_to_array(left[0]); } else { leftAst = left[0]; } } else { leftAst = new AST_Array({ elements: left }); } right = seq_to_array(new AST_Seq({ car: expr.right, cdr: expression(true, no_in) })); ’ê’èitr24 = ’ê’è_Iterable(enumerate(leftAst.elements)); for (’ê’èidx24 = 0; ’ê’èidx24 < ’ê’èitr24.length; ’ê’èidx24++) { ’ê’èupk6 = ’ê’èitr24[’ê’èidx24]; index = ’ê’èupk6[0]; element = ’ê’èupk6[1]; mark_local_assignment(element, right.elements[index]); } return new AST_Assign({ start: start, left: leftAst, operator: expr.operator, right: right, end: peek() }); } expr = maybe_assign(no_in); left.push(expr); } S.in_seq = false; if (expr instanceof AST_Assign && expr.left instanceof AST_Seq) { expr.left = seq_to_array(expr.left); } if (left.length > 1 && left[left.length-1] instanceof AST_Assign) { left[left.length-1] = left[left.length-1].left; ’ê’èitr25 = ’ê’è_Iterable(enumerate(left)); for (’ê’èidx25 = 0; ’ê’èidx25 < ’ê’èitr25.length; ’ê’èidx25++) { ’ê’èupk7 = ’ê’èitr25[’ê’èidx25]; index = ’ê’èupk7[0]; element = ’ê’èupk7[1]; mark_local_assignment(element, expr.right instanceof AST_Array ? expr.right.elements[index] : null); } return new AST_Assign({ start: start, left: new AST_Array({ elements: left }), operator: expr.operator, right: expr.right, end: peek() }); } seq = function build_seq(a) { var ’ê’èitr26, ’ê’èidx26, ’ê’èupk8; var first, index, element; first = a.shift(); if (first instanceof AST_Assign) { if (first.left instanceof AST_Array) { ’ê’èitr26 = ’ê’è_Iterable(enumerate(first.left.elements)); for (’ê’èidx26 = 0; ’ê’èidx26 < ’ê’èitr26.length; ’ê’èidx26++) { ’ê’èupk8 = ’ê’èitr26[’ê’èidx26]; index = ’ê’èupk8[0]; element = ’ê’èupk8[1]; mark_local_assignment(element, first.right instanceof AST_Array ? first.right.elements[index] : null); } } } if (!a.length) { return first; } return new AST_Seq({ start: start, car: first, cdr: build_seq(a), end: peek() }); }(left); return seq; } return expr; } function in_loop(cont) { var ret; ++S.in_loop; ret = cont(); --S.in_loop; return ret; } return function() { var ’ê’èitr27, ’ê’èidx27; var start, body, docstring, first_token, element, shebang, end, toplevel, assignments, callables, item; start = S.token; body = []; docstring = null; first_token = true; while (!is_("eof")) { element = statement(); if (first_token && element instanceof AST_Directive && element.value.indexOf("#!") === 0) { shebang = element.value; } else if (!body.length && is_docstring(element)) { docstring = format_docstring(element.value); } else { body.push(element); } first_token = false; } end = prev(); toplevel = options.toplevel; if (toplevel) { toplevel.body = toplevel.body.concat(body); toplevel.end = end; } else { toplevel = new AST_Toplevel({ start: start, body: body, strict: true, shebang: shebang, docstring: docstring, end: end }); } function uniq(element, index, arr) { return arr.lastIndexOf(element) === index; } toplevel.nonlocalvars = Object.keys(S.in_scope[S.in_scope.length-1].nonlocal); assignments = Object.keys(S.in_scope[S.in_scope.length-1].vars); callables = scan_for_top_level_callables(toplevel.body).filter(uniq); toplevel.localvars = []; ’ê’èitr27 = ’ê’è_Iterable(assignments); for (’ê’èidx27 = 0; ’ê’èidx27 < ’ê’èitr27.length; ’ê’èidx27++) { item = ’ê’èitr27[’ê’èidx27]; if (!(’ê’è_in(item, toplevel.nonlocalvars))) { toplevel.localvars.push(new_symbol(AST_SymbolVar, item)); } } toplevel.exports = toplevel.localvars.concat(callables).filter(uniq); toplevel.submodules = []; toplevel.classes = CLASS_MAP; toplevel.import_order = Object.keys(IMPORTED).length; toplevel.module_id = module_id; IMPORTED[module_id] = toplevel; toplevel.imports = IMPORTED; toplevel.baselib = BASELIB; IMPORTING[module_id] = false; return toplevel; }();}var rs_compile=function(a,b){var c=OutputStream({private_scope:!1,omit_baselib:!0,beautify:!0});try{return astTree=parse(b),astTree.print(c),c.toString()}catch(b){console.log("Error:\n"+b.message+".\n"+a+": Line "+b.line+", column "+b.col+".")}};
var rs_compile = function (source, code) {
    var output = OutputStream({"private_scope":false, "omit_baselib":true, "beautify":true});
    try {
        var astTree = parse(code);
        astTree.print(output);
        return output.toString();
    } catch(err) {
        console.log("Error:\n" + err.message + ".\n" + source + ": Line " + err.line + ", column " + err.col + ".");
    }
}
